       |/**
       |        JSON serialization and value handling.
       |
       |        This module provides the Json struct for reading, writing and manipulating
       |        JSON values. De(serialization) of arbitrary D types is also supported and
       |        is recommended for handling JSON in performance sensitive applications.
       |
       |        Copyright: © 2012-2015 RejectedSoftware e.K.
       |        License: Subject to the terms of the MIT license, as written in the included LICENSE.txt file.
       |        Authors: Sönke Ludwig
       |*/
       |module vibe.data.json;
       |
       |///
       |@safe unittest {
       |        void manipulateJson(Json j)
       |        {
       |                import std.stdio;
       |
       |                // retrieving the values is done using get()
       |                assert(j["name"].get!string == "Example");
       |                assert(j["id"].get!int == 1);
       |
       |                // semantic conversions can be done using to()
       |                assert(j["id"].to!string == "1");
       |
       |                // prints:
       |                // name: "Example"
       |                // id: 1
       |                foreach (key, value; j.byKeyValue)
       |                        writefln("%s: %s", key, value);
       |
       |                // print out as JSON: {"name": "Example", "id": 1}
       |                writefln("JSON: %s", j.toString());
       |
       |                // DEPRECATED: object members can be accessed using member syntax, just like in JavaScript
       |                //j = Json.emptyObject;
       |                //j.name = "Example";
       |                //j.id = 1;
       |        }
       |}
       |
       |/// Constructing `Json` objects
       |@safe unittest {
       |        // construct a JSON object {"field1": "foo", "field2": 42, "field3": true}
       |
       |        // using the constructor
       |        Json j1 = Json(["field1": Json("foo"), "field2": Json(42), "field3": Json(true)]);
       |
       |        // using piecewise construction
       |        Json j2 = Json.emptyObject;
       |        j2["field1"] = "foo";
       |        j2["field2"] = 42.0;
       |        j2["field3"] = true;
       |
       |        // using serialization
       |        struct S {
       |                string field1;
       |                double field2;
       |                bool field3;
       |        }
       |        Json j3 = S("foo", 42, true).serializeToJson();
       |
       |        // using serialization, converting directly to a JSON string
       |        string j4 = S("foo", 32, true).serializeToJsonString();
       |}
       |
       |
       |public import vibe.data.serialization;
       |
       |public import std.json : JSONException;
       |import std.algorithm;
       |import std.array;
       |import std.bigint;
       |import std.conv;
       |import std.datetime;
       |import std.exception;
       |import std.format;
       |import std.json : JSONValue, JSON_TYPE;
       |import std.range;
       |import std.string;
       |import std.traits;
       |import std.typecons : Tuple;
       |
       |/******************************************************************************/
       |/* public types                                                               */
       |/******************************************************************************/
       |
       |/**
       |        Represents a single JSON value.
       |
       |        Json values can have one of the types defined in the Json.Type enum. They
       |        behave mostly like values in ECMA script in the way that you can
       |        transparently perform operations on them. However, strict typechecking is
       |        done, so that operations between differently typed JSON values will throw
       |        a JSONException. Additionally, an explicit cast or using get!() or to!() is
       |        required to convert a JSON value to the corresponding static D type.
       |*/
       |align(8) // ensures that pointers stay on 64-bit boundaries on x64 so that they get scanned by the GC
       |struct Json {
       |@safe:
       |
       |        static assert(!hasElaborateDestructor!BigInt && !hasElaborateCopyConstructor!BigInt,
       |                "struct Json is missing required ~this and/or this(this) members for BigInt.");
       |
       |        private {
       |                // putting all fields in a union results in many false pointers leading to
       |                // memory leaks and, worse, std.algorithm.swap triggering an assertion
       |                // because of internal pointers. This crude workaround seems to fix
       |                // the issues.
       |                enum m_size = max((BigInt.sizeof+(void*).sizeof), 2);
       |                // NOTE : DMD 2.067.1 doesn't seem to init void[] correctly on its own.
       |                // Explicity initializing it works around this issue. Using a void[]
       |                // array here to guarantee that it's scanned by the GC.
       |                void[m_size] m_data = (void[m_size]).init;
       |
       |                static assert(m_data.offsetof == 0, "m_data must be the first struct member.");
       |                static assert(BigInt.alignof <= 8, "Json struct alignment of 8 isn't sufficient to store BigInt.");
       |
       |                ref inout(T) getDataAs(T)() inout @trusted {
       |                        static assert(T.sizeof <= m_data.sizeof);
    291|                        return (cast(inout(T)[1])m_data[0 .. T.sizeof])[0];
       |                }
       |
0000000|                @property ref inout(BigInt) m_bigInt() inout { return getDataAs!BigInt(); }
     11|                @property ref inout(long) m_int() inout { return getDataAs!long(); }
     34|                @property ref inout(double) m_float() inout { return getDataAs!double(); }
0000000|                @property ref inout(bool) m_bool() inout { return getDataAs!bool(); }
     99|                @property ref inout(string) m_string() inout { return getDataAs!string(); }
     75|                @property ref inout(Json[string]) m_object() inout { return getDataAs!(Json[string])(); }
     72|                @property ref inout(Json[]) m_array() inout { return getDataAs!(Json[])(); }
       |
       |                Type m_type = Type.undefined;
       |
       |                version (VibeJsonFieldNames) {
       |                        string m_name;
       |                }
       |        }
       |
       |        /** Represents the run time type of a JSON value.
       |        */
       |        enum Type {
       |                undefined,  /// A non-existent value in a JSON object
       |                null_,      /// Null value
       |                bool_,      /// Boolean value
       |                int_,       /// 64-bit integer value
       |                bigInt,     /// BigInt values
       |                float_,     /// 64-bit floating point value
       |                string,     /// UTF-8 string
       |                array,      /// Array of JSON values
       |                object,     /// JSON object aka. dictionary from string to Json
       |
       |                Undefined = undefined,  /// Compatibility alias - will be deprecated soon
       |                Null = null_,           /// Compatibility alias - will be deprecated soon
       |                Bool = bool_,           /// Compatibility alias - will be deprecated soon
       |                Int = int_,             /// Compatibility alias - will be deprecated soon
       |                Float = float_,         /// Compatibility alias - will be deprecated soon
       |                String = string,        /// Compatibility alias - will be deprecated soon
       |                Array = array,          /// Compatibility alias - will be deprecated soon
       |                Object = object         /// Compatibility alias - will be deprecated soon
       |        }
       |
       |        /// New JSON value of Type.Undefined
0000000|        static @property Json undefined() { return Json(); }
       |
       |        /// New JSON value of Type.Object
0000000|        static @property Json emptyObject() { return Json(cast(Json[string])null); }
       |
       |        /// New JSON value of Type.Array
0000000|        static @property Json emptyArray() { return Json(cast(Json[])null); }
       |
       |        version(JsonLineNumbers) int line;
       |
       |        /**
       |                Constructor for a JSON object.
       |        */
      4|        this(typeof(null)) @trusted { m_type = Type.null_; }
       |        /// ditto
0000000|        this(bool v) @trusted { m_type = Type.bool_; m_bool = v; }
       |        /// ditto
0000000|        this(byte v) { this(cast(long)v); }
       |        /// ditto
0000000|        this(ubyte v) { this(cast(long)v); }
       |        /// ditto
0000000|        this(short v) { this(cast(long)v); }
       |        /// ditto
0000000|        this(ushort v) { this(cast(long)v); }
       |        /// ditto
      2|        this(int v) { this(cast(long)v); }
       |        /// ditto
0000000|        this(uint v) { this(cast(long)v); }
       |        /// ditto
      6|        this(long v) @trusted { m_type = Type.int_; m_int = v; }
       |        /// ditto
0000000|        this(BigInt v) @trusted { m_type = Type.bigInt; initBigInt(); m_bigInt = v; }
       |        /// ditto
     12|        this(double v) @trusted { m_type = Type.float_; m_float = v; }
       |        /// ditto
     51|        this(string v) @trusted { m_type = Type.string; m_string = v; }
       |        /// ditto
     60|        this(Json[] v) @trusted { m_type = Type.array; m_array = v; }
       |        /// ditto
     27|        this(Json[string] v) @trusted { m_type = Type.object; m_object = v; }
       |
       |        /**
       |                Converts a std.json.JSONValue object to a vibe Json object.
       |         */
0000000|        this(in JSONValue value)
       |        @safe {
0000000|                final switch (value.type) {
0000000|                        case JSON_TYPE.NULL: this = null; break;
0000000|                        case JSON_TYPE.OBJECT:
0000000|                                this = emptyObject;
0000000|                                () @trusted {
0000000|                                        foreach (string k, ref const JSONValue v; value.object)
0000000|                                                this[k] = Json(v);
       |                                } ();
0000000|                                break;
0000000|                        case JSON_TYPE.ARRAY:
0000000|                                this = (() @trusted => Json(value.array.map!(a => Json(a)).array))();
0000000|                                break;
0000000|                        case JSON_TYPE.STRING: this = value.str; break;
0000000|                        case JSON_TYPE.INTEGER: this = value.integer; break;
0000000|                        case JSON_TYPE.UINTEGER: this = BigInt(value.uinteger); break;
0000000|                        case JSON_TYPE.FLOAT: this = value.floating; break;
0000000|                        case JSON_TYPE.TRUE: this = true; break;
0000000|                        case JSON_TYPE.FALSE: this = false; break;
       |                }
       |        }
       |
       |
       |        /**
       |                Allows assignment of D values to a JSON value.
       |        */
       |        ref Json opAssign(Json v)
       |        {
     37|                if (v.type != Type.bigInt)
     37|                        runDestructors();
     37|                auto old_type = m_type;
     37|                m_type = v.m_type;
     37|                final switch(m_type){
0000000|                        case Type.undefined: m_string = null; break;
      6|                        case Type.null_: m_string = null; break;
0000000|                        case Type.bool_: m_bool = v.m_bool; break;
0000000|                        case Type.int_: m_int = v.m_int; break;
0000000|                        case Type.bigInt:
0000000|                                if (old_type != Type.bigInt)
0000000|                                        initBigInt();
0000000|                                m_bigInt = v.m_bigInt;
0000000|                                break;
0000000|                        case Type.float_: m_float = v.m_float; break;
     30|                        case Type.string: m_string = v.m_string; break;
     48|                        case Type.array: opAssign(v.m_array); break;
     27|                        case Type.object: opAssign(v.m_object); break;
       |                }
     37|                return this;
       |        }
       |        /// ditto
0000000|        void opAssign(typeof(null)) { runDestructors(); m_type = Type.null_; m_string = null; }
       |        /// ditto
0000000|        bool opAssign(bool v) { runDestructors(); m_type = Type.bool_; m_bool = v; return v; }
       |        /// ditto
0000000|        int opAssign(int v) { runDestructors(); m_type = Type.int_; m_int = v; return v; }
       |        /// ditto
      4|        long opAssign(long v) { runDestructors(); m_type = Type.int_; m_int = v; return v; }
       |        /// ditto
       |        BigInt opAssign(BigInt v)
       |        {
0000000|                if (m_type != Type.bigInt)
0000000|                        initBigInt();
0000000|                m_type = Type.bigInt;
0000000|                m_bigInt = v;
0000000|                return v;
       |        }
       |        /// ditto
     36|        double opAssign(double v) { runDestructors(); m_type = Type.float_; m_float = v; return v; }
       |        /// ditto
     64|        string opAssign(string v) { runDestructors(); m_type = Type.string; m_string = v; return v; }
       |        /// ditto
       |        Json[] opAssign(Json[] v) {
     16|                runDestructors();
     16|                m_type = Type.array;
     16|                m_array = v;
       |                version (VibeJsonFieldNames) {
       |                        foreach (idx, ref av; m_array)
       |                                av.m_name = format("%s[%s]", m_name, idx);
       |                }
     16|                return v;
       |        }
       |        /// ditto
       |        Json[string] opAssign(Json[string] v)
       |        {
     25|                runDestructors();
     25|                m_type = Type.object;
     25|                m_object = v;
       |                version (VibeJsonFieldNames) { foreach (key, ref av; m_object) av.m_name = format("%s.%s", m_name, key); }
     25|                return v;
       |        }
       |
       |        /**
       |                Allows removal of values from Type.Object Json objects.
       |        */
0000000|        void remove(string item) { checkType!(Json[string])(); m_object.remove(item); }
       |
       |        /**
       |                The current type id of this JSON object.
       |        */
    227|        @property Type type() const @safe { return m_type; }
       |
       |        /**
       |                Clones a JSON value recursively.
       |        */
       |        Json clone()
       |        const {
0000000|                final switch (m_type) {
0000000|                        case Type.undefined: return Json.undefined;
0000000|                        case Type.null_: return Json(null);
0000000|                        case Type.bool_: return Json(m_bool);
0000000|                        case Type.int_: return Json(m_int);
0000000|                        case Type.bigInt: return Json(m_bigInt);
0000000|                        case Type.float_: return Json(m_float);
0000000|                        case Type.string: return Json(m_string);
0000000|                        case Type.array:
0000000|                                auto ret = Json.emptyArray;
0000000|                                foreach (v; this.byValue) ret ~= v.clone();
0000000|                                return ret;
0000000|                        case Type.object:
0000000|                                auto ret = Json.emptyObject;
0000000|                                foreach (name, v; this.byKeyValue) ret[name] = v.clone();
0000000|                                return ret;
       |                }
       |        }
       |
       |        /**
       |                Allows direct indexing of array typed JSON values.
       |        */
0000000|        ref inout(Json) opIndex(size_t idx) inout { checkType!(Json[])(); return m_array[idx]; }
       |
       |        ///
       |        unittest {
       |                Json value = Json.emptyArray;
       |                value ~= 1;
       |                value ~= true;
       |                value ~= "foo";
       |                assert(value[0] == 1);
       |                assert(value[1] == true);
       |                assert(value[2] == "foo");
       |        }
       |
       |
       |        /**
       |                Allows direct indexing of object typed JSON values using a string as
       |                the key.
       |
       |                Returns an object of `Type.undefined` if the key was not found.
       |        */
       |        const(Json) opIndex(string key)
       |        const {
0000000|                checkType!(Json[string])();
0000000|                if( auto pv = key in m_object ) return *pv;
0000000|                Json ret = Json.undefined;
0000000|                ret.m_string = key;
       |                version (VibeJsonFieldNames) ret.m_name = format("%s.%s", m_name, key);
0000000|                return ret;
       |        }
       |        /// ditto
       |        ref Json opIndex(string key)
       |        {
0000000|                checkType!(Json[string])();
0000000|                if( auto pv = key in m_object )
0000000|                        return *pv;
0000000|                if (m_object is null) {
0000000|                        m_object = ["": Json.init];
0000000|                        m_object.remove("");
       |                }
0000000|                m_object[key] = Json.init;
0000000|                assert(m_object !is null);
0000000|                assert(key in m_object, "Failed to insert key '"~key~"' into AA!?");
0000000|                m_object[key].m_type = Type.undefined; // DMDBUG: AAs are teh $H1T!!!11
0000000|                assert(m_object[key].type == Type.undefined);
0000000|                m_object[key].m_string = key;
       |                version (VibeJsonFieldNames) m_object[key].m_name = format("%s.%s", m_name, key);
0000000|                return m_object[key];
       |        }
       |
       |        ///
       |        unittest {
       |                Json value = Json.emptyObject;
       |                value["a"] = 1;
       |                value["b"] = true;
       |                value["c"] = "foo";
       |                assert(value["a"] == 1);
       |                assert(value["b"] == true);
       |                assert(value["c"] == "foo");
       |                assert(value["not-existing"].type() == Type.undefined);
       |        }
       |
       |        /**
       |                Returns a slice of a JSON array.
       |        */
0000000|        inout(Json[]) opSlice() inout { checkType!(Json[])(); return m_array; }
       |        ///
0000000|        inout(Json[]) opSlice(size_t from, size_t to) inout { checkType!(Json[])(); return m_array[from .. to]; }
       |
       |        /**
       |                Returns the number of entries of string, array or object typed JSON values.
       |        */
       |        @property size_t length()
       |        const @trusted {
      5|                checkType!(string, Json[], Json[string])("property length");
      5|                switch(m_type){
     10|                        case Type.string: return m_string.length;
0000000|                        case Type.array: return m_array.length;
0000000|                        case Type.object: return m_object.length;
0000000|                        default: assert(false);
       |                }
       |        }
       |
       |        /**
       |                Allows foreach iterating over JSON objects and arrays.
       |        */
       |        int opApply(scope int delegate(ref Json obj) del)
       |        @system {
0000000|                checkType!(Json[], Json[string])("opApply");
0000000|                if( m_type == Type.array ){
0000000|                        foreach( ref v; m_array )
0000000|                                if( auto ret = del(v) )
0000000|                                        return ret;
0000000|                        return 0;
       |                } else {
0000000|                        foreach( ref v; m_object )
0000000|                                if( v.type != Type.undefined )
0000000|                                        if( auto ret = del(v) )
0000000|                                                return ret;
0000000|                        return 0;
       |                }
       |        }
       |        /// ditto
       |        int opApply(scope int delegate(ref const Json obj) del)
       |        const @system {
0000000|                checkType!(Json[], Json[string])("opApply");
0000000|                if( m_type == Type.array ){
0000000|                        foreach( ref v; m_array )
0000000|                                if( auto ret = del(v) )
0000000|                                        return ret;
0000000|                        return 0;
       |                } else {
0000000|                        foreach( ref v; m_object )
0000000|                                if( v.type != Type.undefined )
0000000|                                        if( auto ret = del(v) )
0000000|                                                return ret;
0000000|                        return 0;
       |                }
       |        }
       |        /// ditto
       |        int opApply(scope int delegate(ref size_t idx, ref Json obj) del)
       |        @system {
0000000|                checkType!(Json[])("opApply");
0000000|                foreach( idx, ref v; m_array )
0000000|                        if( auto ret = del(idx, v) )
0000000|                                return ret;
0000000|                return 0;
       |        }
       |        /// ditto
       |        int opApply(scope int delegate(ref size_t idx, ref const Json obj) del)
       |        const @system {
0000000|                checkType!(Json[])("opApply");
0000000|                foreach( idx, ref v; m_array )
0000000|                        if( auto ret = del(idx, v) )
0000000|                                return ret;
0000000|                return 0;
       |        }
       |        /// ditto
       |        int opApply(scope int delegate(ref string idx, ref Json obj) del)
       |        @system {
0000000|                checkType!(Json[string])("opApply");
0000000|                foreach( idx, ref v; m_object )
0000000|                        if( v.type != Type.undefined )
0000000|                                if( auto ret = del(idx, v) )
0000000|                                        return ret;
0000000|                return 0;
       |        }
       |        /// ditto
       |        int opApply(scope int delegate(ref string idx, ref const Json obj) del)
       |        const @system {
      5|                checkType!(Json[string])("opApply");
      5|                foreach( idx, ref v; m_object )
      9|                        if( v.type != Type.undefined )
      9|                                if( auto ret = del(idx, v) )
0000000|                                        return ret;
      5|                return 0;
       |        }
       |
       |        private alias KeyValue = Tuple!(string, "key", Json, "value");
       |
       |        /// Iterates over all key/value pairs of an object.
0000000|        @property auto byKeyValue() @trusted { checkType!(Json[string])("byKeyValue"); return m_object.byKeyValue.map!(kv => KeyValue(kv.key, kv.value)).trustedRange; }
       |        /// ditto
     48|        @property auto byKeyValue() const @trusted { checkType!(Json[string])("byKeyValue"); return m_object.byKeyValue.map!(kv => const(KeyValue)(kv.key, kv.value)).trustedRange; }
       |        /// Iterates over all index/value pairs of an array.
0000000|        @property auto byIndexValue() { checkType!(Json[])("byIndexValue"); return zip(iota(0, m_array.length), m_array); }
       |        /// ditto
0000000|        @property auto byIndexValue() const { checkType!(Json[])("byIndexValue"); return zip(iota(0, m_array.length), m_array); }
       |        /// Iterates over all values of an object or array.
       |        @property auto byValue() @trusted {
0000000|                checkType!(Json[], Json[string])("byValue");
0000000|                static struct Rng {
       |                        private {
       |                                bool isArray;
       |                                Json[] array;
       |                                typeof(Json.init.m_object.byValue) object;
       |                        }
       |
0000000|                        bool empty() @trusted { if (isArray) return array.length == 0; else return object.empty; }
0000000|                        auto front() @trusted { if (isArray) return array[0]; else return object.front; }
0000000|                        void popFront() @trusted { if (isArray) array = array[1 .. $]; else object.popFront(); }
       |                }
       |
0000000|                if (m_type == Type.array) return Rng(true, m_array);
0000000|                else return Rng(false, null, m_object.byValue);
       |        }
       |        /// ditto
       |        @property auto byValue() const @trusted {
     20|                checkType!(Json[], Json[string])("byValue");
     20|                static struct Rng {
       |                @safe:
       |                        private {
       |                                bool isArray;
       |                                const(Json)[] array;
       |                                typeof(const(Json).init.m_object.byValue) object;
       |                        }
       |
     96|                        bool empty() @trusted { if (isArray) return array.length == 0; else return object.empty; }
     56|                        auto front() @trusted { if (isArray) return array[0]; else return object.front; }
     56|                        void popFront() @trusted { if (isArray) array = array[1 .. $]; else object.popFront(); }
       |                }
       |
     40|                if (m_type == Type.array) return Rng(true, m_array);
0000000|                else return Rng(false, null, m_object.byValue);
       |        }
       |
       |
       |        /**
       |                Converts this Json object to a std.json.JSONValue object
       |         */
       |        T opCast(T)() const @safe
       |                if (is(T == JSONValue))
       |        {
       |                final switch (type) {
       |                        case Json.Type.undefined:
       |                        case Json.Type.null_:
       |                                return JSONValue(null);
       |                        case Json.Type.bool_:
       |                                return JSONValue(get!bool);
       |                        case Json.Type.int_:
       |                                return JSONValue(get!long);
       |                        case Json.Type.bigInt:
       |                                auto bi = get!BigInt;
       |                                if (bi > long.max)
       |                                        return JSONValue((() @trusted => cast(ulong)get!BigInt)());
       |                                else
       |                                        return JSONValue((() @trusted => cast(long)get!BigInt)());
       |                        case Json.Type.float_:
       |                                return JSONValue(get!double);
       |                        case Json.Type.string:
       |                                return JSONValue(get!string);
       |                        case Json.Type.array:
       |                                JSONValue[] ret;
       |                                foreach (ref const Json e; byValue)
       |                                        ret ~= cast(JSONValue)e;
       |                                return JSONValue(ret);
       |                        case Json.Type.object:
       |                                JSONValue[string] ret;
       |                                foreach (string k, ref const Json e; byKeyValue) {
       |                                        if( e.type == Json.Type.undefined ) continue;
       |                                        ret[k] = cast(JSONValue)e;
       |                                }
       |                                return JSONValue(ret);
       |                }
       |        }
       |
       |
       |        /**
       |                Converts the JSON value to the corresponding D type - types must match exactly.
       |
       |                Available_Types:
       |                        $(UL
       |                                $(LI `bool` (`Type.bool_`))
       |                                $(LI `double` (`Type.float_`))
       |                                $(LI `float` (Converted from `double`))
       |                                $(LI `long` (`Type.int_`))
       |                                $(LI `ulong`, `int`, `uint`, `short`, `ushort`, `byte`, `ubyte` (Converted from `long`))
       |                                $(LI `string` (`Type.string`))
       |                                $(LI `Json[]` (`Type.array`))
       |                                $(LI `Json[string]` (`Type.object`))
       |                        )
       |
       |                See_Also: `opt`, `to`, `deserializeJson`
       |        */
     11|        inout(T) opCast(T)() inout if (!is(T == JSONValue)) { return get!T; }
       |        /// ditto
       |        @property inout(T) get(T)()
       |        inout @trusted {
       |                static if (!is(T : bool) && is(T : long))
      2|                        checkType!(long, BigInt)();
       |                else
     44|                        checkType!T();
       |
0000000|                static if (is(T == bool)) return m_bool;
     17|                else static if (is(T == double)) return m_float;
       |                else static if (is(T == float)) return cast(T)m_float;
     27|                else static if (is(T == string)) return m_string;
       |                else static if (is(T == Json[])) return m_array;
       |                else static if (is(T == Json[string])) return m_object;
0000000|                else static if (is(T == BigInt)) return m_type == Type.bigInt ? m_bigInt : BigInt(m_int);
       |                else static if (is(T : long)) {
      2|                        if (m_type == Type.bigInt) {
0000000|                                enforceJson(m_bigInt <= T.max && m_bigInt >= T.min, "Integer conversion out of bounds error");
0000000|                                return cast(T)m_bigInt.toLong();
       |                        } else {
      4|                                enforceJson(m_int <= T.max && m_int >= T.min, "Integer conversion out of bounds error");
      2|                                return cast(T)m_int;
       |                        }
       |                }
       |                else static assert(0, "JSON can only be cast to (bool, long, std.bigint.BigInt, double, string, Json[] or Json[string]. Not "~T.stringof~".");
       |        }
       |
       |        /**
       |                Returns the native type for this JSON if it matches the current runtime type.
       |
       |                If the runtime type does not match the given native type, the 'def' parameter is returned
       |                instead.
       |
       |                See_Also: `get`
       |        */
       |        @property const(T) opt(T)(const(T) def = T.init)
       |        const {
       |                if( typeId!T != m_type ) return def;
       |                return get!T;
       |        }
       |        /// ditto
       |        @property T opt(T)(T def = T.init)
       |        {
       |                if( typeId!T != m_type ) return def;
       |                return get!T;
       |        }
       |
       |        /**
       |                Converts the JSON value to the corresponding D type - types are converted as necessary.
       |
       |                Automatically performs conversions between strings and numbers. See
       |                `get` for the list of available types. For converting/deserializing
       |                JSON to complex data types see `deserializeJson`.
       |
       |                See_Also: `get`, `deserializeJson`
       |        */
       |        @property inout(T) to(T)()
       |        inout {
       |                static if( is(T == bool) ){
       |                        final switch( m_type ){
       |                                case Type.undefined: return false;
       |                                case Type.null_: return false;
       |                                case Type.bool_: return m_bool;
       |                                case Type.int_: return m_int != 0;
       |                                case Type.bigInt: return m_bigInt != 0;
       |                                case Type.float_: return m_float != 0;
       |                                case Type.string: return m_string.length > 0;
       |                                case Type.array: return m_array.length > 0;
       |                                case Type.object: return m_object.length > 0;
       |                        }
       |                } else static if( is(T == double) ){
       |                        final switch( m_type ){
       |                                case Type.undefined: return T.init;
       |                                case Type.null_: return 0;
       |                                case Type.bool_: return m_bool ? 1 : 0;
       |                                case Type.int_: return m_int;
       |                                case Type.bigInt: return bigIntToLong();
       |                                case Type.float_: return m_float;
       |                                case Type.string: return .to!double(cast(string)m_string);
       |                                case Type.array: return double.init;
       |                                case Type.object: return double.init;
       |                        }
       |                } else static if( is(T == float) ){
       |                        final switch( m_type ){
       |                                case Type.undefined: return T.init;
       |                                case Type.null_: return 0;
       |                                case Type.bool_: return m_bool ? 1 : 0;
       |                                case Type.int_: return m_int;
       |                                case Type.bigInt: return bigIntToLong();
       |                                case Type.float_: return m_float;
       |                                case Type.string: return .to!float(cast(string)m_string);
       |                                case Type.array: return float.init;
       |                                case Type.object: return float.init;
       |                        }
       |                } else static if( is(T == long) ){
       |                        final switch( m_type ){
       |                                case Type.undefined: return 0;
       |                                case Type.null_: return 0;
       |                                case Type.bool_: return m_bool ? 1 : 0;
       |                                case Type.int_: return m_int;
       |                                case Type.bigInt: return cast(long)bigIntToLong();
       |                                case Type.float_: return cast(long)m_float;
       |                                case Type.string: return .to!long(m_string);
       |                                case Type.array: return 0;
       |                                case Type.object: return 0;
       |                        }
       |                } else static if( is(T : long) ){
       |                        final switch( m_type ){
       |                                case Type.undefined: return 0;
       |                                case Type.null_: return 0;
       |                                case Type.bool_: return m_bool ? 1 : 0;
       |                                case Type.int_: return cast(T)m_int;
       |                                case Type.bigInt: return cast(T)bigIntToLong();
       |                                case Type.float_: return cast(T)m_float;
       |                                case Type.string: return cast(T).to!long(cast(string)m_string);
       |                                case Type.array: return 0;
       |                                case Type.object: return 0;
       |                        }
       |                } else static if( is(T == string) ){
       |                        switch( m_type ){
       |                                default: return toString();
       |                                case Type.string: return m_string;
       |                        }
       |                } else static if( is(T == Json[]) ){
       |                        switch( m_type ){
       |                                default: return Json([this]);
       |                                case Type.array: return m_array;
       |                        }
       |                } else static if( is(T == Json[string]) ){
       |                        switch( m_type ){
       |                                default: return Json(["value": this]);
       |                                case Type.object: return m_object;
       |                        }
       |                } else static if( is(T == BigInt) ){
       |                        final switch( m_type ){
       |                                case Type.undefined: return BigInt(0);
       |                                case Type.null_: return BigInt(0);
       |                                case Type.bool_: return BigInt(m_bool ? 1 : 0);
       |                                case Type.int_: return BigInt(m_int);
       |                                case Type.bigInt: return m_bigInt;
       |                                case Type.float_: return BigInt(cast(long)m_float);
       |                                case Type.string: return BigInt(.to!long(m_string));
       |                                case Type.array: return BigInt(0);
       |                                case Type.object: return BigInt(0);
       |                        }
       |                } else static if (is(T == JSONValue)) {
       |                        return cast(JSONValue)this;
       |                } else static assert(0, "JSON can only be cast to (bool, long, std.bigint.BigInt, double, string, Json[] or Json[string]. Not "~T.stringof~".");
       |        }
       |
       |        /**
       |                Performs unary operations on the JSON value.
       |
       |                The following operations are supported for each type:
       |
       |                $(DL
       |                        $(DT Null)   $(DD none)
       |                        $(DT Bool)   $(DD ~)
       |                        $(DT Int)    $(DD +, -, ++, --)
       |                        $(DT Float)  $(DD +, -, ++, --)
       |                        $(DT String) $(DD none)
       |                        $(DT Array)  $(DD none)
       |                        $(DT Object) $(DD none)
       |                )
       |        */
       |        Json opUnary(string op)()
       |        const {
       |                static if( op == "~" ){
       |                        checkType!bool();
       |                        return Json(~m_bool);
       |                } else static if( op == "+" || op == "-" || op == "++" || op == "--" ){
       |                        checkType!(BigInt, long, double)("unary "~op);
       |                        if( m_type == Type.int_ ) mixin("return Json("~op~"m_int);");
       |                        else if( m_type == Type.bigInt ) mixin("return Json("~op~"m_bigInt);");
       |                        else if( m_type == Type.float_ ) mixin("return Json("~op~"m_float);");
       |                        else assert(false);
       |                } else static assert(0, "Unsupported operator '"~op~"' for type JSON.");
       |        }
       |        /**
       |                Performs binary operations between JSON values.
       |
       |                The two JSON values must be of the same run time type or a JSONException
       |                will be thrown. Only the operations listed are allowed for each of the
       |                types.
       |
       |                $(DL
       |                        $(DT Null)   $(DD none)
       |                        $(DT Bool)   $(DD &&, ||)
       |                        $(DT Int)    $(DD +, -, *, /, %)
       |                        $(DT Float)  $(DD +, -, *, /, %)
       |                        $(DT String) $(DD ~)
       |                        $(DT Array)  $(DD ~)
       |                        $(DT Object) $(DD in)
       |                )
       |        */
       |        Json opBinary(string op)(ref const(Json) other)
       |        const {
       |                enforceJson(m_type == other.m_type, "Binary operation '"~op~"' between "~.to!string(m_type)~" and "~.to!string(other.m_type)~" JSON objects.");
       |                static if( op == "&&" ){
       |                        checkType!(bool)(op);
       |                        return Json(m_bool && other.m_bool);
       |                } else static if( op == "||" ){
       |                        checkType!(bool)(op);
       |                        return Json(m_bool || other.m_bool);
       |                } else static if( op == "+" ){
       |                        checkType!(BigInt, long, double)(op);
       |                        if( m_type == Type.int_ ) return Json(m_int + other.m_int);
       |                        else if( m_type == Type.bigInt ) return Json(() @trusted { return m_bigInt + other.m_bigInt; } ());
       |                        else if( m_type == Type.float_ ) return Json(m_float + other.m_float);
       |                        else assert(false);
       |                } else static if( op == "-" ){
       |                        checkType!(BigInt, long, double)(op);
       |                        if( m_type == Type.int_ ) return Json(m_int - other.m_int);
       |                        else if( m_type == Type.bigInt ) return Json(() @trusted { return m_bigInt - other.m_bigInt; } ());
       |                        else if( m_type == Type.float_ ) return Json(m_float - other.m_float);
       |                        else assert(false);
       |                } else static if( op == "*" ){
       |                        checkType!(BigInt, long, double)(op);
       |                        if( m_type == Type.int_ ) return Json(m_int * other.m_int);
       |                        else if( m_type == Type.bigInt ) return Json(() @trusted { return m_bigInt * other.m_bigInt; } ());
       |                        else if( m_type == Type.float_ ) return Json(m_float * other.m_float);
       |                        else assert(false);
       |                } else static if( op == "/" ){
       |                        checkType!(BigInt, long, double)(op);
       |                        if( m_type == Type.int_ ) return Json(m_int / other.m_int);
       |                        else if( m_type == Type.bigInt ) return Json(() @trusted { return m_bigInt / other.m_bigInt; } ());
       |                        else if( m_type == Type.float_ ) return Json(m_float / other.m_float);
       |                        else assert(false);
       |                } else static if( op == "%" ){
       |                        checkType!(BigInt, long, double)(op);
       |                        if( m_type == Type.int_ ) return Json(m_int % other.m_int);
       |                        else if( m_type == Type.bigInt ) return Json(() @trusted { return m_bigInt % other.m_bigInt; } ());
       |                        else if( m_type == Type.float_ ) return Json(m_float % other.m_float);
       |                        else assert(false);
       |                } else static if( op == "~" ){
       |                        checkType!(string, Json[])(op);
       |                        if( m_type == Type.string ) return Json(m_string ~ other.m_string);
       |                        else if (m_type == Type.array) return Json(m_array ~ other.m_array);
       |                        else assert(false);
       |                } else static assert(0, "Unsupported operator '"~op~"' for type JSON.");
       |        }
       |        /// ditto
       |        Json opBinary(string op)(Json other)
       |                if( op == "~" )
       |        {
       |                static if( op == "~" ){
       |                        checkType!(string, Json[])(op);
       |                        if( m_type == Type.string ) return Json(m_string ~ other.m_string);
       |                        else if( m_type == Type.array ) return Json(m_array ~ other.m_array);
       |                        else assert(false);
       |                } else static assert(0, "Unsupported operator '"~op~"' for type JSON.");
       |        }
       |        /// ditto
       |        void opOpAssign(string op)(Json other)
       |                if (op == "+" || op == "-" || op == "*" || op == "/" || op == "%" || op =="~")
       |        {
0000000|                enforceJson(m_type == other.m_type || op == "~" && m_type == Type.array,
0000000|                                "Binary operation '"~op~"=' between "~.to!string(m_type)~" and "~.to!string(other.m_type)~" JSON objects.");
       |                static if( op == "+" ){
       |                        if( m_type == Type.int_ ) m_int += other.m_int;
       |                        else if( m_type == Type.bigInt ) m_bigInt += other.m_bigInt;
       |                        else if( m_type == Type.float_ ) m_float += other.m_float;
       |                        else enforceJson(false, "'+=' only allowed for scalar types, not "~.to!string(m_type)~".");
       |                } else static if( op == "-" ){
       |                        if( m_type == Type.int_ ) m_int -= other.m_int;
       |                        else if( m_type == Type.bigInt ) m_bigInt -= other.m_bigInt;
       |                        else if( m_type == Type.float_ ) m_float -= other.m_float;
       |                        else enforceJson(false, "'-=' only allowed for scalar types, not "~.to!string(m_type)~".");
       |                } else static if( op == "*" ){
       |                        if( m_type == Type.int_ ) m_int *= other.m_int;
       |                        else if( m_type == Type.bigInt ) m_bigInt *= other.m_bigInt;
       |                        else if( m_type == Type.float_ ) m_float *= other.m_float;
       |                        else enforceJson(false, "'*=' only allowed for scalar types, not "~.to!string(m_type)~".");
       |                } else static if( op == "/" ){
       |                        if( m_type == Type.int_ ) m_int /= other.m_int;
       |                        else if( m_type == Type.bigInt ) m_bigInt /= other.m_bigInt;
       |                        else if( m_type == Type.float_ ) m_float /= other.m_float;
       |                        else enforceJson(false, "'/=' only allowed for scalar types, not "~.to!string(m_type)~".");
       |                } else static if( op == "%" ){
       |                        if( m_type == Type.int_ ) m_int %= other.m_int;
       |                        else if( m_type == Type.bigInt ) m_bigInt %= other.m_bigInt;
       |                        else if( m_type == Type.float_ ) m_float %= other.m_float;
       |                        else enforceJson(false, "'%=' only allowed for scalar types, not "~.to!string(m_type)~".");
       |                } else static if( op == "~" ){
0000000|                        if (m_type == Type.string) m_string ~= other.m_string;
0000000|                        else if (m_type == Type.array) {
0000000|                                if (other.m_type == Type.array) m_array ~= other.m_array;
0000000|                                else appendArrayElement(other);
0000000|                        } else enforceJson(false, "'~=' only allowed for string and array types, not "~.to!string(m_type)~".");
       |                } else static assert(0, "Unsupported operator '"~op~"=' for type JSON.");
       |        }
       |        /// ditto
       |        void opOpAssign(string op, T)(T other)
       |                if (!is(T == Json) && is(typeof(Json(other))))
       |        {
       |                opOpAssign!op(Json(other));
       |        }
       |        /// ditto
       |        Json opBinary(string op)(bool other) const { checkType!bool(); mixin("return Json(m_bool "~op~" other);"); }
       |        /// ditto
       |        Json opBinary(string op)(long other) const
       |        {
       |                checkType!(long, BigInt)();
       |                if (m_type == Type.bigInt)
       |                        mixin("return Json(m_bigInt "~op~" other);");
       |                else
       |                        mixin("return Json(m_int "~op~" other);");
       |        }
       |        /// ditto
       |        Json opBinary(string op)(BigInt other) const
       |        {
       |                checkType!(long, BigInt)();
       |                if (m_type == Type.bigInt)
       |                        mixin("return Json(m_bigInt "~op~" other);");
       |                else
       |                        mixin("return Json(m_int "~op~" other);");
       |        }
       |        /// ditto
       |        Json opBinary(string op)(double other) const { checkType!double(); mixin("return Json(m_float "~op~" other);"); }
       |        /// ditto
       |        Json opBinary(string op)(string other) const { checkType!string(); mixin("return Json(m_string "~op~" other);"); }
       |        /// ditto
       |        Json opBinary(string op)(Json[] other) { checkType!(Json[])(); mixin("return Json(m_array "~op~" other);"); }
       |        /// ditto
       |        Json opBinaryRight(string op)(bool other) const { checkType!bool(); mixin("return Json(other "~op~" m_bool);"); }
       |        /// ditto
       |        Json opBinaryRight(string op)(long other) const
       |        {
       |                checkType!(long, BigInt)();
       |                if (m_type == Type.bigInt)
       |                        mixin("return Json(other "~op~" m_bigInt);");
       |                else
       |                        mixin("return Json(other "~op~" m_int);");
       |        }
       |        /// ditto
       |        Json opBinaryRight(string op)(BigInt other) const
       |        {
       |                checkType!(long, BigInt)();
       |                if (m_type == Type.bigInt)
       |                        mixin("return Json(other "~op~" m_bigInt);");
       |                else
       |                        mixin("return Json(other "~op~" m_int);");
       |        }
       |        /// ditto
       |        Json opBinaryRight(string op)(double other) const { checkType!double(); mixin("return Json(other "~op~" m_float);"); }
       |        /// ditto
       |        Json opBinaryRight(string op)(string other) const if(op == "~") { checkType!string(); return Json(other ~ m_string); }
       |        /// ditto
       |        Json opBinaryRight(string op)(Json[] other) { checkType!(Json[])(); mixin("return Json(other "~op~" m_array);"); }
       |
       |
       |        /** Checks wheter a particular key is set and returns a pointer to it.
       |
       |                For field that don't exist or have a type of `Type.undefined`,
       |                the `in` operator will return `null`.
       |        */
       |        inout(Json)* opBinaryRight(string op)(string other) inout
       |                if(op == "in")
       |        {
       |                checkType!(Json[string])();
       |                auto pv = other in m_object;
       |                if (!pv) return null;
       |                if (pv.type == Type.undefined) return null;
       |                return pv;
       |        }
       |
       |        ///
       |        unittest {
       |                auto j = Json.emptyObject;
       |                j["a"] = "foo";
       |                j["b"] = Json.undefined;
       |
       |                assert("a" in j);
       |                assert(("a" in j).get!string == "foo");
       |                assert("b" !in j);
       |                assert("c" !in j);
       |        }
       |
       |
       |        /**
       |         * The append operator will append arrays. This method always appends it's argument as an array element, so nested arrays can be created.
       |         */
       |        void appendArrayElement(Json element)
       |        {
0000000|                enforceJson(m_type == Type.array, "'appendArrayElement' only allowed for array types, not "~.to!string(m_type)~".");
0000000|                m_array ~= element;
       |        }
       |
       |        /**
       |                Compares two JSON values for equality.
       |
       |                If the two values have different types, they are considered unequal.
       |                This differs with ECMA script, which performs a type conversion before
       |                comparing the values.
       |        */
       |
       |        bool opEquals(ref const Json other)
       |        const {
     16|                if( m_type != other.m_type ) return false;
     16|                final switch(m_type){
0000000|                        case Type.undefined: return false;
0000000|                        case Type.null_: return true;
0000000|                        case Type.bool_: return m_bool == other.m_bool;
      2|                        case Type.int_: return m_int == other.m_int;
0000000|                        case Type.bigInt: return m_bigInt == other.m_bigInt;
      4|                        case Type.float_: return m_float == other.m_float;
     12|                        case Type.string: return m_string == other.m_string;
0000000|                        case Type.array: return m_array == other.m_array;
     14|                        case Type.object: return m_object == other.m_object;
       |                }
       |        }
       |        /// ditto
0000000|        bool opEquals(const Json other) const { return opEquals(other); }
       |        /// ditto
0000000|        bool opEquals(typeof(null)) const { return m_type == Type.null_; }
       |        /// ditto
0000000|        bool opEquals(bool v) const { return m_type == Type.bool_ && m_bool == v; }
       |        /// ditto
0000000|        bool opEquals(int v) const { return (m_type == Type.int_ && m_int == v) || (m_type == Type.bigInt && m_bigInt == v); }
       |        /// ditto
0000000|        bool opEquals(long v) const { return (m_type == Type.int_ && m_int == v) || (m_type == Type.bigInt && m_bigInt == v); }
       |        /// ditto
0000000|        bool opEquals(BigInt v) const { return (m_type == Type.int_ && m_int == v) || (m_type == Type.bigInt && m_bigInt == v); }
       |        /// ditto
0000000|        bool opEquals(double v) const { return m_type == Type.float_ && m_float == v; }
       |        /// ditto
0000000|        bool opEquals(string v) const { return m_type == Type.string && m_string == v; }
       |
       |        /**
       |                Compares two JSON values.
       |
       |                If the types of the two values differ, the value with the smaller type
       |                id is considered the smaller value. This differs from ECMA script, which
       |                performs a type conversion before comparing the values.
       |
       |                JSON values of type Object cannot be compared and will throw an
       |                exception.
       |        */
       |        int opCmp(ref const Json other)
       |        const {
0000000|                if( m_type != other.m_type ) return m_type < other.m_type ? -1 : 1;
0000000|                final switch(m_type){
0000000|                        case Type.undefined: return 0;
0000000|                        case Type.null_: return 0;
0000000|                        case Type.bool_: return m_bool < other.m_bool ? -1 : m_bool == other.m_bool ? 0 : 1;
0000000|                        case Type.int_: return m_int < other.m_int ? -1 : m_int == other.m_int ? 0 : 1;
0000000|                        case Type.bigInt: return () @trusted { return m_bigInt < other.m_bigInt; } () ? -1 : m_bigInt == other.m_bigInt ? 0 : 1;
0000000|                        case Type.float_: return m_float < other.m_float ? -1 : m_float == other.m_float ? 0 : 1;
0000000|                        case Type.string: return m_string < other.m_string ? -1 : m_string == other.m_string ? 0 : 1;
0000000|                        case Type.array: return m_array < other.m_array ? -1 : m_array == other.m_array ? 0 : 1;
0000000|                        case Type.object:
0000000|                                enforceJson(false, "JSON objects cannot be compared.");
0000000|                                assert(false);
       |                }
       |        }
       |
       |        alias opDollar = length;
       |
       |        /**
       |                Returns the type id corresponding to the given D type.
       |        */
       |        static @property Type typeId(T)() {
       |                static if( is(T == typeof(null)) ) return Type.null_;
0000000|                else static if( is(T == bool) ) return Type.bool_;
     17|                else static if( is(T == double) ) return Type.float_;
       |                else static if( is(T == float) ) return Type.float_;
      2|                else static if( is(T : long) ) return Type.int_;
     32|                else static if( is(T == string) ) return Type.string;
     25|                else static if( is(T == Json[]) ) return Type.array;
     43|                else static if( is(T == Json[string]) ) return Type.object;
      2|                else static if( is(T == BigInt) ) return Type.bigInt;
       |                else static assert(false, "Unsupported JSON type '"~T.stringof~"'. Only bool, long, std.bigint.BigInt, double, string, Json[] and Json[string] are allowed.");
       |        }
       |
       |        /**
       |                Returns the JSON object as a string.
       |
       |                For large JSON values use writeJsonString instead as this function will store the whole string
       |                in memory, whereas writeJsonString writes it out bit for bit.
       |
       |                See_Also: writeJsonString, toPrettyString
       |        */
       |        string toString()
       |        const @trusted {
       |                // DMD BUG: this should actually be all @safe, but for some reason
       |                // @safe inference for writeJsonString doesn't work.
     14|                auto ret = appender!string();
     14|                writeJsonString(ret, this);
     14|                return ret.data;
       |        }
       |        /// ditto
       |        void toString(scope void delegate(const(char)[]) @safe sink, FormatSpec!char fmt)
       |        @trusted {
       |                // DMD BUG: this should actually be all @safe, but for some reason
       |                // @safe inference for writeJsonString doesn't work.
0000000|                static struct DummyRangeS {
       |                        void delegate(const(char)[]) @safe sink;
0000000|                        void put(const(char)[] str) @safe { sink(str); }
0000000|                        void put(char ch) @trusted { sink((&ch)[0 .. 1]); }
       |                }
0000000|                auto r = DummyRangeS(sink);
0000000|                writeJsonString(r, this);
       |        }
       |        /// ditto
       |        void toString(scope void delegate(const(char)[]) @system sink, FormatSpec!char fmt)
       |        @system {
       |                // DMD BUG: this should actually be all @safe, but for some reason
       |                // @safe inference for writeJsonString doesn't work.
0000000|                static struct DummyRange {
       |                        void delegate(const(char)[]) sink;
       |                        @trusted:
0000000|                        void put(const(char)[] str) { sink(str); }
0000000|                        void put(char ch) { sink((&ch)[0 .. 1]); }
       |                }
0000000|                auto r = DummyRange(sink);
0000000|                writeJsonString(r, this);
       |        }
       |
       |        /**
       |                Returns the JSON object as a "pretty" string.
       |
       |                ---
       |                auto json = Json(["foo": Json("bar")]);
       |                writeln(json.toPrettyString());
       |
       |                // output:
       |                // {
       |                //     "foo": "bar"
       |                // }
       |                ---
       |
       |                Params:
       |                        level = Specifies the base amount of indentation for the output. Indentation  is always
       |                                done using tab characters.
       |
       |                See_Also: writePrettyJsonString, toString
       |        */
       |        string toPrettyString(int level = 0)
       |        const @trusted {
0000000|                auto ret = appender!string();
0000000|                writePrettyJsonString(ret, this, level);
0000000|                return ret.data;
       |        }
       |
       |        private void checkType(TYPES...)(string op = null)
       |        const {
     89|                bool matched = false;
    331|                foreach (T; TYPES) if (m_type == typeId!T) matched = true;
    178|                if (matched) return;
       |
0000000|                string name;
       |                version (VibeJsonFieldNames) {
       |                        if (m_name.length) name = m_name ~ " of type " ~ m_type.to!string;
       |                        else name = "JSON of type " ~ m_type.to!string;
0000000|                } else name = "JSON of type " ~ m_type.to!string;
       |
0000000|                string expected;
0000000|                static if (TYPES.length == 1) expected = typeId!(TYPES[0]).to!string;
       |                else {
0000000|                        foreach (T; TYPES) {
0000000|                                if (expected.length > 0) expected ~= ", ";
0000000|                                expected ~= typeId!T.to!string;
       |                        }
       |                }
       |
0000000|                if (!op.length) throw new JSONException(format("Got %s, expected %s.", name, expected));
0000000|                else throw new JSONException(format("Got %s, expected %s for %s.", name, expected, op));
       |        }
       |
       |        private void initBigInt()
       |        @trusted {
0000000|                BigInt[1] init_;
       |                // BigInt is a struct, and it has a special BigInt.init value, which differs from null.
       |                // m_data has no special initializer and when it tries to first access to BigInt
       |                // via m_bigInt(), we should explicitly initialize m_data with BigInt.init
0000000|                m_data[0 .. BigInt.sizeof] = cast(void[])init_;
       |        }
       |
       |        private void runDestructors()
       |        {
    208|                if (m_type != Type.bigInt) return;
       |
0000000|                BigInt init_;
       |                // After swaping, init_ contains the real number from Json, and it
       |                // will be destroyed when this function is finished.
       |                // m_bigInt now contains static BigInt.init value and destruction may
       |                // be ommited for it.
0000000|                swap(init_, m_bigInt);
       |        }
       |
       |        private long bigIntToLong() inout
       |        {
0000000|                assert(m_type == Type.bigInt, format("Converting non-bigInt type with bitIntToLong!?: %s", cast(Type)m_type));
0000000|                enforceJson(m_bigInt >= long.min && m_bigInt <= long.max, "Number out of range while converting BigInt("~format("%d", m_bigInt)~") to long.");
0000000|                return m_bigInt.toLong();
       |        }
       |
       |        /*invariant()
       |        {
       |                assert(m_type >= Type.Undefined && m_type <= Type.Object);
       |        }*/
       |}
       |
       |@safe unittest { // issue #1234 - @safe toString
       |        auto j = Json(true);
       |        j.toString((str) @safe {}, FormatSpec!char("s"));
       |        assert(j.toString() == "true");
       |}
       |
       |
       |/******************************************************************************/
       |/* public functions                                                           */
       |/******************************************************************************/
       |
       |/**
       |        Parses the given range as a JSON string and returns the corresponding Json object.
       |
       |        The range is shrunk during parsing, leaving any remaining text that is not part of
       |        the JSON contents.
       |
       |        Throws a JSONException if any parsing error occured.
       |*/
       |Json parseJson(R)(ref R range, int* line = null, string filename = null)
       |        if( is(R == string) )
       |{
     42|        Json ret;
     42|        enforceJson(!range.empty, "JSON string is empty.", filename, 0);
       |
     42|        skipWhitespace(range, line);
       |
     42|        enforceJson(!range.empty, "JSON string contains only whitespaces.", filename, 0);
       |
       |        version(JsonLineNumbers) {
       |                int curline = line ? *line : 0;
       |        }
       |
     42|        bool minus = false;
     42|        switch( range.front ){
0000000|                case 'f':
0000000|                        enforceJson(range[1 .. $].startsWith("alse"), "Expected 'false', got '"~range[0 .. min(5, $)]~"'.", filename, line);
0000000|                        range.popFrontN(5);
0000000|                        ret = false;
0000000|                        break;
0000000|                case 'n':
0000000|                        enforceJson(range[1 .. $].startsWith("ull"), "Expected 'null', got '"~range[0 .. min(4, $)]~"'.", filename, line);
0000000|                        range.popFrontN(4);
0000000|                        ret = null;
0000000|                        break;
0000000|                case 't':
0000000|                        enforceJson(range[1 .. $].startsWith("rue"), "Expected 'true', got '"~range[0 .. min(4, $)]~"'.", filename, line);
0000000|                        range.popFrontN(4);
0000000|                        ret = true;
0000000|                        break;
       |
0000000|                case '-':
    164|                case '0': .. case '9':
     10|                        bool is_long_overflow;
     10|                        bool is_float;
     10|                        auto num = skipNumber(range, is_float, is_long_overflow);
     10|                        if( is_float ) {
      9|                                ret = to!double(num);
      1|                        } else if (is_long_overflow) {
0000000|                                ret = () @trusted { return BigInt(num.to!string); } ();
       |                        } else {
      1|                                ret = to!long(num);
       |                        }
     10|                        break;
     16|                case '\"':
     16|                        ret = skipJsonString(range);
     16|                        break;
0000000|                case '[':
0000000|                        auto arr = appender!(Json[]);
0000000|                        range.popFront();
0000000|                        while (true) {
0000000|                                skipWhitespace(range, line);
0000000|                                enforceJson(!range.empty, "Missing ']' before EOF.", filename, line);
0000000|                                if(range.front == ']') break;
0000000|                                arr ~= parseJson(range, line, filename);
0000000|                                skipWhitespace(range, line);
0000000|                                enforceJson(!range.empty, "Missing ']' before EOF.", filename, line);
0000000|                                enforceJson(range.front == ',' || range.front == ']',
0000000|                                        format("Expected ']' or ',' - got '%s'.", range.front), filename, line);
0000000|                                if( range.front == ']' ) break;
0000000|                                else range.popFront();
       |                        }
0000000|                        range.popFront();
0000000|                        ret = arr.data;
0000000|                        break;
     16|                case '{':
     16|                        Json[string] obj;
     16|                        range.popFront();
     27|                        while (true) {
     27|                                skipWhitespace(range, line);
     27|                                enforceJson(!range.empty, "Missing '}' before EOF.", filename, line);
     27|                                if(range.front == '}') break;
     27|                                string key = skipJsonString(range);
     27|                                skipWhitespace(range, line);
     27|                                enforceJson(range.startsWith(":"), "Expected ':' for key '" ~ key ~ "'", filename, line);
     27|                                range.popFront();
     27|                                skipWhitespace(range, line);
     27|                                Json itm = parseJson(range, line, filename);
     54|                                obj[key] = itm;
     27|                                skipWhitespace(range, line);
     27|                                enforceJson(!range.empty, "Missing '}' before EOF.", filename, line);
     43|                                enforceJson(range.front == ',' || range.front == '}',
0000000|                                        format("Expected '}' or ',' - got '%s'.", range.front), filename, line);
     43|                                if (range.front == '}') break;
     11|                                else range.popFront();
       |                        }
     16|                        range.popFront();
     16|                        ret = obj;
     16|                        break;
0000000|                default:
0000000|                        enforceJson(false, format("Expected valid JSON token, got '%s'.", range[0 .. min(12, $)]), filename, line);
0000000|                        assert(false);
       |        }
       |
     42|        assert(ret.type != Json.Type.undefined);
       |        version(JsonLineNumbers) ret.line = curline;
     42|        return ret;
       |}
       |
       |/**
       |        Parses the given JSON string and returns the corresponding Json object.
       |
       |        Throws a JSONException if any parsing error occurs.
       |*/
       |Json parseJsonString(string str, string filename = null)
       |@safe {
     15|        auto strcopy = str;
     15|        int line = 0;
     30|        auto ret = parseJson(strcopy, () @trusted { return &line; } (), filename);
     15|        enforceJson(strcopy.strip().length == 0, "Expected end of string after JSON value.", filename, line);
     15|        return ret;
       |}
       |
       |@safe unittest {
       |        // These currently don't work at compile time
       |        assert(parseJsonString("17559991181826658461") == Json(BigInt(17559991181826658461UL)));
       |        assert(parseJsonString("99999999999999999999999999") == () @trusted { return Json(BigInt("99999999999999999999999999")); } ());
       |        auto json = parseJsonString(`{"hey": "This is @à test éhééhhéhéé !%/??*&?\ud83d\udcec"}`);
       |        assert(json.toPrettyString() == parseJsonString(json.toPrettyString()).toPrettyString());
       |
       |        bool test() {
       |                assert(parseJsonString("null") == Json(null));
       |                assert(parseJsonString("true") == Json(true));
       |                assert(parseJsonString("false") == Json(false));
       |                assert(parseJsonString("1") == Json(1));
       |                assert(parseJsonString("2.0") == Json(2.0));
       |                assert(parseJsonString("\"test\"") == Json("test"));
       |                assert(parseJsonString("[1, 2, 3]") == Json([Json(1), Json(2), Json(3)]));
       |                assert(parseJsonString("{\"a\": 1}") == Json(["a": Json(1)]));
       |                assert(parseJsonString(`"\\\/\b\f\n\r\t\u1234"`).get!string == "\\/\b\f\n\r\t\u1234");
       |
       |                return true;
       |        }
       |
       |        // Run at compile time and runtime
       |        assert(test());
       |        static assert(test());
       |}
       |
       |@safe unittest {
       |        bool test() {
       |                try parseJsonString(" \t\n ");
       |                catch (Exception e) assert(e.msg.endsWith("JSON string contains only whitespaces."));
       |                try parseJsonString(`{"a": 1`);
       |                catch (Exception e) assert(e.msg.endsWith("Missing '}' before EOF."));
       |                try parseJsonString(`{"a": 1 x`);
       |                catch (Exception e) assert(e.msg.endsWith("Expected '}' or ',' - got 'x'."));
       |                try parseJsonString(`[1`);
       |                catch (Exception e) assert(e.msg.endsWith("Missing ']' before EOF."));
       |                try parseJsonString(`[1 x`);
       |                catch (Exception e) assert(e.msg.endsWith("Expected ']' or ',' - got 'x'."));
       |
       |                return true;
       |        }
       |
       |        // Run at compile time and runtime
       |        assert(test());
       |        static assert(test());
       |}
       |
       |/**
       |        Serializes the given value to JSON.
       |
       |        The following types of values are supported:
       |
       |        $(DL
       |                $(DT `Json`)            $(DD Used as-is)
       |                $(DT `null`)            $(DD Converted to `Json.Type.null_`)
       |                $(DT `bool`)            $(DD Converted to `Json.Type.bool_`)
       |                $(DT `float`, `double`)   $(DD Converted to `Json.Type.float_`)
       |                $(DT `short`, `ushort`, `int`, `uint`, `long`, `ulong`) $(DD Converted to `Json.Type.int_`)
       |                $(DT `BigInt`)          $(DD Converted to `Json.Type.bigInt`)
       |                $(DT `string`)          $(DD Converted to `Json.Type.string`)
       |                $(DT `T[]`)             $(DD Converted to `Json.Type.array`)
       |                $(DT `T[string]`)       $(DD Converted to `Json.Type.object`)
       |                $(DT `struct`)          $(DD Converted to `Json.Type.object`)
       |                $(DT `class`)           $(DD Converted to `Json.Type.object` or `Json.Type.null_`)
       |        )
       |
       |        All entries of an array or an associative array, as well as all R/W properties and
       |        all public fields of a struct/class are recursively serialized using the same rules.
       |
       |        Fields ending with an underscore will have the last underscore stripped in the
       |        serialized output. This makes it possible to use fields with D keywords as their name
       |        by simply appending an underscore.
       |
       |        The following methods can be used to customize the serialization of structs/classes:
       |
       |        ---
       |        Json toJson() const;
       |        static T fromJson(Json src);
       |
       |        string toString() const;
       |        static T fromString(string src);
       |        ---
       |
       |        The methods will have to be defined in pairs. The first pair that is implemented by
       |        the type will be used for serialization (i.e. `toJson` overrides `toString`).
       |
       |        See_Also: `deserializeJson`, `vibe.data.serialization`
       |*/
       |Json serializeToJson(T)(T value)
       |{
       |        return serialize!JsonSerializer(value);
       |}
       |/// ditto
       |void serializeToJson(R, T)(R destination, T value)
       |        if (isOutputRange!(R, char) || isOutputRange!(R, ubyte))
       |{
       |        serialize!(JsonStringSerializer!R)(value, destination);
       |}
       |/// ditto
       |string serializeToJsonString(T)(T value)
       |{
       |        auto ret = appender!string;
       |        serializeToJson(ret, value);
       |        return ret.data;
       |}
       |
       |///
       |@safe unittest {
       |        struct Foo {
       |                int number;
       |                string str;
       |        }
       |
       |        Foo f;
       |
       |        f.number = 12;
       |        f.str = "hello";
       |
       |        string json = serializeToJsonString(f);
       |        assert(json == `{"number":12,"str":"hello"}`);
       |        Json jsonval = serializeToJson(f);
       |        assert(jsonval.type == Json.Type.object);
       |        assert(jsonval["number"] == Json(12));
       |        assert(jsonval["str"] == Json("hello"));
       |}
       |
       |
       |/**
       |        Serializes the given value to a pretty printed JSON string.
       |
       |        See_also: `serializeToJson`, `vibe.data.serialization`
       |*/
       |void serializeToPrettyJson(R, T)(R destination, T value)
       |        if (isOutputRange!(R, char) || isOutputRange!(R, ubyte))
       |{
       |        serialize!(JsonStringSerializer!(R, true))(value, destination);
       |}
       |/// ditto
       |string serializeToPrettyJson(T)(T value)
       |{
       |        auto ret = appender!string;
       |        serializeToPrettyJson(ret, value);
       |        return ret.data;
       |}
       |
       |///
       |@safe unittest {
       |        struct Foo {
       |                int number;
       |                string str;
       |        }
       |
       |        Foo f;
       |        f.number = 12;
       |        f.str = "hello";
       |
       |        string json = serializeToPrettyJson(f);
       |        assert(json ==
       |`{
       |        "number": 12,
       |        "str": "hello"
       |}`);
       |}
       |
       |
       |/**
       |        Deserializes a JSON value into the destination variable.
       |
       |        The same types as for `serializeToJson()` are supported and handled inversely.
       |
       |        See_Also: `serializeToJson`, `serializeToJsonString`, `vibe.data.serialization`
       |*/
       |void deserializeJson(T)(ref T dst, Json src)
       |{
       |        dst = deserializeJson!T(src);
       |}
       |/// ditto
       |T deserializeJson(T)(Json src)
       |{
       |        return deserialize!(JsonSerializer, T)(src);
       |}
       |/// ditto
       |T deserializeJson(T, R)(R input)
       |        if (!is(R == Json) && isInputRange!R)
       |{
       |        return deserialize!(JsonStringSerializer!R, T)(input);
       |}
       |
       |///
       |@safe unittest {
       |        struct Foo {
       |                int number;
       |                string str;
       |        }
       |        Foo f = deserializeJson!Foo(`{"number": 12, "str": "hello"}`);
       |        assert(f.number == 12);
       |        assert(f.str == "hello");
       |}
       |
       |@safe unittest {
       |        import std.stdio;
       |        enum Foo : string { k = "test" }
       |        enum Boo : int { l = 5 }
       |        static struct S { float a; double b; bool c; int d; string e; byte f; ubyte g; long h; ulong i; float[] j; Foo k; Boo l; }
       |        immutable S t = {1.5, -3.0, true, int.min, "Test", -128, 255, long.min, ulong.max, [1.1, 1.2, 1.3], Foo.k, Boo.l};
       |        S u;
       |        deserializeJson(u, serializeToJson(t));
       |        assert(t.a == u.a);
       |        assert(t.b == u.b);
       |        assert(t.c == u.c);
       |        assert(t.d == u.d);
       |        assert(t.e == u.e);
       |        assert(t.f == u.f);
       |        assert(t.g == u.g);
       |        assert(t.h == u.h);
       |        assert(t.i == u.i);
       |        assert(t.j == u.j);
       |        assert(t.k == u.k);
       |        assert(t.l == u.l);
       |}
       |
       |@safe unittest
       |{
       |        assert(uint.max == serializeToJson(uint.max).deserializeJson!uint);
       |        assert(ulong.max == serializeToJson(ulong.max).deserializeJson!ulong);
       |}
       |
       |unittest {
       |        static struct A { int value; static A fromJson(Json val) @safe { return A(val.get!int); } Json toJson() const @safe { return Json(value); } }
       |        static struct C { int value; static C fromString(string val) @safe { return C(val.to!int); } string toString() const @safe { return value.to!string; } }
       |        static struct D { int value; }
       |
       |        assert(serializeToJson(const A(123)) == Json(123));
       |        assert(serializeToJson(A(123))       == Json(123));
       |        assert(serializeToJson(const C(123)) == Json("123"));
       |        assert(serializeToJson(C(123))       == Json("123"));
       |        assert(serializeToJson(const D(123)) == serializeToJson(["value": 123]));
       |        assert(serializeToJson(D(123))       == serializeToJson(["value": 123]));
       |}
       |
       |unittest {
       |        auto d = Date(2001,1,1);
       |        deserializeJson(d, serializeToJson(Date.init));
       |        assert(d == Date.init);
       |        deserializeJson(d, serializeToJson(Date(2001,1,1)));
       |        assert(d == Date(2001,1,1));
       |        struct S { immutable(int)[] x; }
       |        S s;
       |        deserializeJson(s, serializeToJson(S([1,2,3])));
       |        assert(s == S([1,2,3]));
       |        struct T {
       |                @optional S s;
       |                @optional int i;
       |                @optional float f_; // underscore strip feature
       |                @optional double d;
       |                @optional string str;
       |        }
       |        auto t = T(S([1,2,3]));
       |        deserializeJson(t, parseJsonString(`{ "s" : null, "i" : null, "f" : null, "d" : null, "str" : null }`));
       |        assert(text(t) == text(T()));
       |}
       |
       |unittest {
       |        static class C {
       |                @safe:
       |                int a;
       |                private int _b;
       |                @property int b() const { return _b; }
       |                @property void b(int v) { _b = v; }
       |
       |                @property int test() const { return 10; }
       |
       |                void test2() {}
       |        }
       |        C c = new C;
       |        c.a = 1;
       |        c.b = 2;
       |
       |        C d;
       |        deserializeJson(d, serializeToJson(c));
       |        assert(c.a == d.a);
       |        assert(c.b == d.b);
       |}
       |
       |unittest {
       |        static struct C { @safe: int value; static C fromString(string val) { return C(val.to!int); } string toString() const { return value.to!string; } }
       |        enum Color { Red, Green, Blue }
       |        {
       |                static class T {
       |                        @safe:
       |                        string[Color] enumIndexedMap;
       |                        string[C] stringableIndexedMap;
       |                        this() {
       |                                enumIndexedMap = [ Color.Red : "magenta", Color.Blue : "deep blue" ];
       |                                                                stringableIndexedMap = [ C(42) : "forty-two" ];
       |                        }
       |                }
       |
       |                T original = new T;
       |                original.enumIndexedMap[Color.Green] = "olive";
       |                T other;
       |                deserializeJson(other, serializeToJson(original));
       |                assert(serializeToJson(other) == serializeToJson(original));
       |        }
       |        {
       |                static struct S {
       |                        string[Color] enumIndexedMap;
       |                        string[C] stringableIndexedMap;
       |                }
       |
       |                S *original = new S;
       |                original.enumIndexedMap = [ Color.Red : "magenta", Color.Blue : "deep blue" ];
       |                original.enumIndexedMap[Color.Green] = "olive";
       |                                original.stringableIndexedMap = [ C(42) : "forty-two" ];
       |                S other;
       |                deserializeJson(other, serializeToJson(original));
       |                assert(serializeToJson(other) == serializeToJson(original));
       |        }
       |}
       |
       |unittest {
       |        import std.typecons : Nullable;
       |
       |        struct S { Nullable!int a, b; }
       |        S s;
       |        s.a = 2;
       |
       |        auto j = serializeToJson(s);
       |        assert(j["a"].type == Json.Type.int_);
       |        assert(j["b"].type == Json.Type.null_);
       |
       |        auto t = deserializeJson!S(j);
       |        assert(!t.a.isNull() && t.a == 2);
       |        assert(t.b.isNull());
       |}
       |
       |unittest { // #840
       |        int[2][2] nestedArray = 1;
       |        assert(nestedArray.serializeToJson.deserializeJson!(typeof(nestedArray)) == nestedArray);
       |}
       |
       |unittest { // #1109
       |        static class C {
       |                @safe:
       |                int mem;
       |                this(int m) { mem = m; }
       |                static C fromJson(Json j) { return new C(j.get!int-1); }
       |                Json toJson() const { return Json(mem+1); }
       |        }
       |        const c = new C(13);
       |        assert(serializeToJson(c) == Json(14));
       |        assert(deserializeJson!C(Json(14)).mem == 13);
       |}
       |
       |unittest { // const and mutable json
       |        Json j = Json(1);
       |        const k = Json(2);
       |        assert(serializeToJson(j) == Json(1));
       |        assert(serializeToJson(k) == Json(2));
       |}
       |
       |unittest { // issue #1660 - deserialize AA whose key type is string-based enum
       |        enum Foo: string
       |        {
       |                Bar = "bar",
       |                Buzz = "buzz"
       |        }
       |
       |        struct S {
       |                int[Foo] f;
       |        }
       |
       |        const s = S([Foo.Bar: 2000]);
       |        assert(serializeToJson(s)["f"] == Json([Foo.Bar: Json(2000)]));
       |
       |        auto j = Json.emptyObject;
       |        j["f"] = [Foo.Bar: Json(2000)];
       |        assert(deserializeJson!S(j).f == [Foo.Bar: 2000]);
       |}
       |
       |/**
       |        Serializer for a plain Json representation.
       |
       |        See_Also: vibe.data.serialization.serialize, vibe.data.serialization.deserialize, serializeToJson, deserializeJson
       |*/
       |struct JsonSerializer {
       |        template isJsonBasicType(T) { enum isJsonBasicType = std.traits.isNumeric!T || isBoolean!T || is(T == string) || is(T == typeof(null)) || isJsonSerializable!T; }
       |
       |        template isSupportedValueType(T) { enum isSupportedValueType = isJsonBasicType!T || is(T == Json) || is (T == JSONValue); }
       |
       |        private {
       |                Json m_current;
       |                Json[] m_compositeStack;
       |        }
       |
0000000|        this(Json data) @safe { m_current = data; }
       |
       |        @disable this(this);
       |
       |        //
       |        // serialization
       |        //
0000000|        Json getSerializedResult() @safe { return m_current; }
       |        void beginWriteDictionary(Traits)() { m_compositeStack ~= Json.emptyObject; }
       |        void endWriteDictionary(Traits)() { m_current = m_compositeStack[$-1]; m_compositeStack.length--; }
       |        void beginWriteDictionaryEntry(Traits)(string name) {}
       |        void endWriteDictionaryEntry(Traits)(string name) { m_compositeStack[$-1][name] = m_current; }
       |
       |        void beginWriteArray(Traits)(size_t) { m_compositeStack ~= Json.emptyArray; }
       |        void endWriteArray(Traits)() { m_current = m_compositeStack[$-1]; m_compositeStack.length--; }
       |        void beginWriteArrayEntry(Traits)(size_t) {}
       |        void endWriteArrayEntry(Traits)(size_t) { m_compositeStack[$-1].appendArrayElement(m_current); }
       |
       |        void writeValue(Traits, T)(in T value)
       |                if (!is(T == Json))
       |        {
       |                static if (is(T == JSONValue)) {
       |                        m_current = Json(value);
       |                } else static if (isJsonSerializable!T) {
       |                        static if (!__traits(compiles, () @safe { return value.toJson(); } ()))
       |                                pragma(msg, "Non-@safe toJson/fromJson methods are deprecated - annotate "~T.stringof~".toJson() with @safe.");
       |                        m_current = () @trusted { return value.toJson(); } ();
       |                } else m_current = Json(value);
       |        }
       |
       |        void writeValue(Traits, T)(Json value) if (is(T == Json)) { m_current = value; }
       |        void writeValue(Traits, T)(in Json value) if (is(T == Json)) { m_current = value.clone; }
       |
       |        //
       |        // deserialization
       |        //
       |        void readDictionary(Traits)(scope void delegate(string) @safe field_handler)
       |        {
       |                enforceJson(m_current.type == Json.Type.object, "Expected JSON object, got "~m_current.type.to!string);
       |                auto old = m_current;
       |                foreach (string key, value; m_current.get!(Json[string])) {
       |                        m_current = value;
       |                        field_handler(key);
       |                }
       |                m_current = old;
       |        }
       |
       |        void beginReadDictionaryEntry(Traits)(string name) {}
       |        void endReadDictionaryEntry(Traits)(string name) {}
       |
       |        void readArray(Traits)(scope void delegate(size_t) @safe size_callback, scope void delegate() @safe entry_callback)
       |        {
       |                enforceJson(m_current.type == Json.Type.array, "Expected JSON array, got "~m_current.type.to!string);
       |                auto old = m_current;
       |                size_callback(m_current.length);
       |                foreach (ent; old.get!(Json[])) {
       |                        m_current = ent;
       |                        entry_callback();
       |                }
       |                m_current = old;
       |        }
       |
       |        void beginReadArrayEntry(Traits)(size_t index) {}
       |        void endReadArrayEntry(Traits)(size_t index) {}
       |
       |        T readValue(Traits, T)()
       |        @safe {
       |                static if (is(T == Json)) return m_current;
       |                else static if (is(T == JSONValue)) return cast(JSONValue)m_current;
       |                else static if (isJsonSerializable!T) {
       |                        static if (!__traits(compiles, () @safe { return T.fromJson(m_current); } ()))
       |                                pragma(msg, "Non-@safe toJson/fromJson methods are deprecated - annotate "~T.stringof~".fromJson() with @safe.");
       |                        return () @trusted { return T.fromJson(m_current); } ();
       |                } else static if (is(T == float) || is(T == double)) {
       |                        switch (m_current.type) {
       |                                default: return cast(T)m_current.get!long;
       |                                case Json.Type.null_: goto case;
       |                                case Json.Type.undefined: return T.nan;
       |                                case Json.Type.float_: return cast(T)m_current.get!double;
       |                                case Json.Type.bigInt: return cast(T)m_current.bigIntToLong();
       |                        }
       |                }
       |                else {
       |                        return m_current.get!T();
       |                }
       |        }
       |
       |        bool tryReadNull(Traits)() { return m_current.type == Json.Type.null_; }
       |}
       |
       |
       |/**
       |        Serializer for a range based plain JSON string representation.
       |
       |        See_Also: vibe.data.serialization.serialize, vibe.data.serialization.deserialize, serializeToJson, deserializeJson
       |*/
       |struct JsonStringSerializer(R, bool pretty = false)
       |        if (isInputRange!R || isOutputRange!(R, char))
       |{
       |        private {
       |                R m_range;
       |                size_t m_level = 0;
       |        }
       |
       |        template isJsonBasicType(T) { enum isJsonBasicType = std.traits.isNumeric!T || isBoolean!T || is(T == string) || is(T == typeof(null)) || isJsonSerializable!T; }
       |
       |        template isSupportedValueType(T) { enum isSupportedValueType = isJsonBasicType!T || is(T == Json) || is(T == JSONValue); }
       |
       |        this(R range)
       |        {
       |                m_range = range;
       |        }
       |
       |        @disable this(this);
       |
       |        //
       |        // serialization
       |        //
       |        static if (isOutputRange!(R, char)) {
       |                private {
       |                        bool m_firstInComposite;
       |                }
       |
       |                void getSerializedResult() {}
       |
       |                void beginWriteDictionary(Traits)() { startComposite(); m_range.put('{'); }
       |                void endWriteDictionary(Traits)() { endComposite(); m_range.put("}"); }
       |                void beginWriteDictionaryEntry(Traits)(string name)
       |                {
       |                        startCompositeEntry();
       |                        m_range.put('"');
       |                        m_range.jsonEscape(name);
       |                        static if (pretty) m_range.put(`": `);
       |                        else m_range.put(`":`);
       |                }
       |                void endWriteDictionaryEntry(Traits)(string name) {}
       |
       |                void beginWriteArray(Traits)(size_t) { startComposite(); m_range.put('['); }
       |                void endWriteArray(Traits)() { endComposite(); m_range.put(']'); }
       |                void beginWriteArrayEntry(Traits)(size_t) { startCompositeEntry(); }
       |                void endWriteArrayEntry(Traits)(size_t) {}
       |
       |                void writeValue(Traits, T)(in T value)
       |                {
       |                        static if (is(T == typeof(null))) m_range.put("null");
       |                        else static if (is(T == bool)) m_range.put(value ? "true" : "false");
       |                        else static if (is(T : long)) m_range.formattedWrite("%s", value);
       |                        else static if (is(T == BigInt)) () @trusted { m_range.formattedWrite("%d", value); } ();
       |                        else static if (is(T : real)) value == value ? m_range.formattedWrite("%.16g", value) : m_range.put("null");
       |                        else static if (is(T == string)) {
       |                                m_range.put('"');
       |                                m_range.jsonEscape(value);
       |                                m_range.put('"');
       |                        }
       |                        else static if (is(T == Json)) m_range.writeJsonString(value);
       |                        else static if (is(T == JSONValue)) m_range.writeJsonString(Json(value));
       |                        else static if (isJsonSerializable!T) {
       |                                static if (!__traits(compiles, () @safe { return value.toJson(); } ()))
       |                                        pragma(msg, "Non-@safe toJson/fromJson methods are deprecated - annotate "~T.stringof~".toJson() with @safe.");
       |                                m_range.writeJsonString!(R, pretty)(() @trusted { return value.toJson(); } (), m_level);
       |                        } else static assert(false, "Unsupported type: " ~ T.stringof);
       |                }
       |
       |                private void startComposite()
       |                {
       |                        static if (pretty) m_level++;
       |                        m_firstInComposite = true;
       |                }
       |
       |                private void startCompositeEntry()
       |                {
       |                        if (!m_firstInComposite) {
       |                                m_range.put(',');
       |                        } else {
       |                                m_firstInComposite = false;
       |                        }
       |                        static if (pretty) indent();
       |                }
       |
       |                private void endComposite()
       |                {
       |                        static if (pretty) {
       |                                m_level--;
       |                                if (!m_firstInComposite) indent();
       |                        }
       |                        m_firstInComposite = false;
       |                }
       |
       |                private void indent()
       |                {
       |                        m_range.put('\n');
       |                        foreach (i; 0 .. m_level) m_range.put('\t');
       |                }
       |        }
       |
       |        //
       |        // deserialization
       |        //
       |        static if (isInputRange!(R)) {
       |                private {
       |                        int m_line = 0;
       |                }
       |
       |                void readDictionary(Traits)(scope void delegate(string) @safe entry_callback)
       |                {
       |                        m_range.skipWhitespace(&m_line);
       |                        enforceJson(!m_range.empty && m_range.front == '{', "Expecting object.");
       |                        m_range.popFront();
       |                        bool first = true;
       |                        while(true) {
       |                                m_range.skipWhitespace(&m_line);
       |                                enforceJson(!m_range.empty, "Missing '}'.");
       |                                if (m_range.front == '}') {
       |                                        m_range.popFront();
       |                                        break;
       |                                } else if (!first) {
       |                                        enforceJson(m_range.front == ',', "Expecting ',' or '}', not '"~m_range.front.to!string~"'.");
       |                                        m_range.popFront();
       |                                        m_range.skipWhitespace(&m_line);
       |                                } else first = false;
       |
       |                                auto name = m_range.skipJsonString(&m_line);
       |
       |                                m_range.skipWhitespace(&m_line);
       |                                enforceJson(!m_range.empty && m_range.front == ':', "Expecting ':', not '"~m_range.front.to!string~"'.");
       |                                m_range.popFront();
       |
       |                                entry_callback(name);
       |                        }
       |                }
       |
       |                void beginReadDictionaryEntry(Traits)(string name) {}
       |                void endReadDictionaryEntry(Traits)(string name) {}
       |
       |                void readArray(Traits)(scope void delegate(size_t) @safe size_callback, scope void delegate() @safe entry_callback)
       |                {
       |                        m_range.skipWhitespace(&m_line);
       |                        enforceJson(!m_range.empty && m_range.front == '[', "Expecting array.");
       |                        m_range.popFront();
       |                        bool first = true;
       |                        while(true) {
       |                                m_range.skipWhitespace(&m_line);
       |                                enforceJson(!m_range.empty, "Missing ']'.");
       |                                if (m_range.front == ']') {
       |                                        m_range.popFront();
       |                                        break;
       |                                } else if (!first) {
       |                                        enforceJson(m_range.front == ',', "Expecting ',' or ']'.");
       |                                        m_range.popFront();
       |                                } else first = false;
       |
       |                                entry_callback();
       |                        }
       |                }
       |
       |                void beginReadArrayEntry(Traits)(size_t index) {}
       |                void endReadArrayEntry(Traits)(size_t index) {}
       |
       |                T readValue(Traits, T)()
       |                {
       |                        m_range.skipWhitespace(&m_line);
       |                        static if (is(T == typeof(null))) { enforceJson(m_range.take(4).equal("null"), "Expecting 'null'."); return null; }
       |                        else static if (is(T == bool)) {
       |                                bool ret = m_range.front == 't';
       |                                string expected = ret ? "true" : "false";
       |                                foreach (ch; expected) {
       |                                        enforceJson(m_range.front == ch, "Expecting 'true' or 'false'.");
       |                                        m_range.popFront();
       |                                }
       |                                return ret;
       |                        } else static if (is(T : long)) {
       |                                bool is_float;
       |                                bool is_long_overflow;
       |                                auto num = m_range.skipNumber(is_float, is_long_overflow);
       |                                enforceJson(!is_float, "Expecting integer number.");
       |                                enforceJson(!is_long_overflow, num.to!string~" is too big for long.");
       |                                return to!T(num);
       |                        } else static if (is(T : BigInt)) {
       |                                bool is_float;
       |                                bool is_long_overflow;
       |                                auto num = m_range.skipNumber(is_float, is_long_overflow);
       |                                enforceJson(!is_float, "Expecting integer number.");
       |                                return BigInt(num);
       |                        } else static if (is(T : real)) {
       |                                bool is_float;
       |                                bool is_long_overflow;
       |                                auto num = m_range.skipNumber(is_float, is_long_overflow);
       |                                return to!T(num);
       |                        }
       |                        else static if (is(T == string)) return m_range.skipJsonString(&m_line);
       |                        else static if (is(T == Json)) return m_range.parseJson(&m_line);
       |                        else static if (is(T == JSONValue)) return cast(JSONValue)m_range.parseJson(&m_line);
       |                        else static if (isJsonSerializable!T) {
       |                                static if (!__traits(compiles, () @safe { return T.fromJson(Json.init); } ()))
       |                                        pragma(msg, "Non-@safe toJson/fromJson methods are deprecated - annotate "~T.stringof~".fromJson() with @safe.");
       |                                return () @trusted { return T.fromJson(m_range.parseJson(&m_line)); } ();
       |                        } else static assert(false, "Unsupported type: " ~ T.stringof);
       |                }
       |
       |                bool tryReadNull(Traits)()
       |                {
       |                        m_range.skipWhitespace(&m_line);
       |                        if (m_range.front != 'n') return false;
       |                        foreach (ch; "null") {
       |                                enforceJson(m_range.front == ch, "Expecting 'null'.");
       |                                m_range.popFront();
       |                        }
       |                        assert(m_range.empty || m_range.front != 'l');
       |                        return true;
       |                }
       |        }
       |}
       |
       |unittest
       |{
       |        assert(serializeToJsonString(double.nan) == "null");
       |        assert(serializeToJsonString(Json()) == "null");
       |        assert(serializeToJsonString(Json(["bar":Json("baz"),"foo":Json()])) == `{"bar":"baz"}`);
       |
       |        struct Foo{Json bar = Json();}
       |        Foo f;
       |        assert(serializeToJsonString(f) == `{"bar":null}`);
       |}
       |
       |/**
       |        Writes the given JSON object as a JSON string into the destination range.
       |
       |        This function will convert the given JSON value to a string without adding
       |        any white space between tokens (no newlines, no indentation and no padding).
       |        The output size is thus minimized, at the cost of bad human readability.
       |
       |        Params:
       |                dst   = References the string output range to which the result is written.
       |                json  = Specifies the JSON value that is to be stringified.
       |
       |        See_Also: Json.toString, writePrettyJsonString
       |*/
       |void writeJsonString(R, bool pretty = false)(ref R dst, in Json json, size_t level = 0)
       |@safe //        if( isOutputRange!R && is(ElementEncodingType!R == char) )
       |{
     64|        final switch( json.type ){
0000000|                case Json.Type.undefined: dst.put("null"); break;
      6|                case Json.Type.null_: dst.put("null"); break;
0000000|                case Json.Type.bool_: dst.put(json.get!bool ? "true" : "false"); break;
      3|                case Json.Type.int_: formattedWrite(dst, "%d", json.get!long); break;
0000000|                case Json.Type.bigInt: () @trusted { formattedWrite(dst, "%d", json.get!BigInt); } (); break;
      6|                case Json.Type.float_:
      6|                        auto d = json.get!double;
      6|                        if (d != d)
0000000|                                dst.put("null"); // JSON has no NaN value so set null
       |                        else
      6|                                formattedWrite(dst, "%.16g", json.get!double);
      6|                        break;
     22|                case Json.Type.string:
     22|                        dst.put('\"');
     22|                        jsonEscape(dst, json.get!string);
     22|                        dst.put('\"');
     22|                        break;
     20|                case Json.Type.array:
     20|                        dst.put('[');
     20|                        bool first = true;
    124|                        foreach (ref const Json e; json.byValue) {
     38|                                if( !first ) dst.put(",");
     28|                                first = false;
       |                                static if (pretty) {
0000000|                                        dst.put('\n');
0000000|                                        foreach (tab; 0 .. level+1) dst.put('\t');
       |                                }
     28|                                if (e.type == Json.Type.undefined) dst.put("null");
     28|                                else writeJsonString!(R, pretty)(dst, e, level+1);
       |                        }
       |                        static if (pretty) {
0000000|                                if (json.length > 0) {
0000000|                                        dst.put('\n');
0000000|                                        foreach (tab; 0 .. level) dst.put('\t');
       |                                }
       |                        }
     20|                        dst.put(']');
     20|                        break;
     13|                case Json.Type.object:
     13|                        dst.put('{');
     13|                        bool first = true;
    136|                        foreach (string k, ref const Json e; json.byKeyValue) {
     22|                                if( e.type == Json.Type.undefined ) continue;
     31|                                if( !first ) dst.put(',');
     22|                                first = false;
       |                                static if (pretty) {
0000000|                                        dst.put('\n');
0000000|                                        foreach (tab; 0 .. level+1) dst.put('\t');
       |                                }
     22|                                dst.put('\"');
     22|                                jsonEscape(dst, k);
     22|                                dst.put(pretty ? `": ` : `":`);
     22|                                writeJsonString!(R, pretty)(dst, e, level+1);
       |                        }
       |                        static if (pretty) {
0000000|                                if (json.length > 0) {
0000000|                                        dst.put('\n');
0000000|                                        foreach (tab; 0 .. level) dst.put('\t');
       |                                }
       |                        }
     13|                        dst.put('}');
     13|                        break;
       |        }
       |}
       |
       |unittest {
       |        auto a = Json.emptyObject;
       |        a["a"] = Json.emptyArray;
       |        a["b"] = Json.emptyArray;
       |        a["b"] ~= Json(1);
       |        a["b"] ~= Json.emptyObject;
       |
       |        assert(a.toString() == `{"a":[],"b":[1,{}]}` || a.toString() == `{"b":[1,{}],"a":[]}`);
       |        assert(a.toPrettyString() ==
       |`{
       |        "a": [],
       |        "b": [
       |                1,
       |                {}
       |        ]
       |}`
       |                || a.toPrettyString() == `{
       |        "b": [
       |                1,
       |                {}
       |        ],
       |        "a": []
       |}`);
       |}
       |
       |unittest { // #735
       |        auto a = Json.emptyArray;
       |        a ~= "a";
       |        a ~= Json();
       |        a ~= "b";
       |        a ~= null;
       |        a ~= "c";
       |        assert(a.toString() == `["a",null,"b",null,"c"]`);
       |}
       |
       |unittest {
       |        auto a = Json.emptyArray;
       |        a ~= Json(1);
       |        a ~= Json(2);
       |        a ~= Json(3);
       |        a ~= Json(4);
       |        a ~= Json(5);
       |
       |        auto b = Json(a[0..a.length]);
       |        assert(a == b);
       |
       |        auto c = Json(a[0..$]);
       |        assert(a == c);
       |        assert(b == c);
       |
       |        auto d = [Json(1),Json(2),Json(3)];
       |        assert(d == a[0..a.length-2]);
       |        assert(d == a[0..$-2]);
       |}
       |
       |unittest {
       |        auto j = Json(double.init);
       |
       |        assert(j.toString == "null"); // A double nan should serialize to null
       |        j = 17.04f;
       |        assert(j.toString == "17.04");  // A proper double should serialize correctly
       |
       |        double d;
       |        deserializeJson(d, Json.undefined); // Json.undefined should deserialize to nan
       |        assert(d != d);
       |        deserializeJson(d, Json(null)); // Json.undefined should deserialize to nan
       |        assert(d != d);
       |}
       |/**
       |        Writes the given JSON object as a prettified JSON string into the destination range.
       |
       |        The output will contain newlines and indents to make the output human readable.
       |
       |        Params:
       |                dst   = References the string output range to which the result is written.
       |                json  = Specifies the JSON value that is to be stringified.
       |                level = Specifies the base amount of indentation for the output. Indentation  is always
       |                                done using tab characters.
       |
       |        See_Also: Json.toPrettyString, writeJsonString
       |*/
       |void writePrettyJsonString(R)(ref R dst, in Json json, int level = 0)
       |//      if( isOutputRange!R && is(ElementEncodingType!R == char) )
       |{
0000000|        writeJsonString!(R, true)(dst, json, level);
       |}
       |
       |
       |/**
       |        Helper function that escapes all Unicode characters in a JSON string.
       |*/
       |string convertJsonToASCII(string json)
       |{
0000000|        auto ret = appender!string;
0000000|        jsonEscape!true(ret, json);
0000000|        return ret.data;
       |}
       |
       |
       |/// private
       |private void jsonEscape(bool escape_unicode = false, R)(ref R dst, string s)
       |{
     44|        size_t startPos = 0;
       |
     44|        void putInterval(size_t curPos)
       |        {
     44|                if (curPos > startPos)
     44|                        dst.put(s[startPos..curPos]);
     44|                startPos = curPos + 1;
       |        }
       |
    588|        for (size_t pos = 0; pos < s.length; pos++) {
    250|                immutable(char) ch = s[pos];
       |
    250|                switch (ch) {
    250|                        default:
       |                                static if (escape_unicode) {
0000000|                                        if (ch <= 0x20 || ch >= 0x80)
       |                                        {
0000000|                                                putInterval(pos);
       |                                                import std.utf : decode;
0000000|                                                int len;
0000000|                                                dchar codepoint = decode(s, pos);
       |                                                /* codepoint is in BMP */
0000000|                                                if(codepoint < 0x10000)
       |                                                {
0000000|                                                        dst.formattedWrite("\\u%04X", codepoint);
       |                                                }
       |                                                /* not in BMP -> construct a UTF-16 surrogate pair */
       |                                                else
       |                                                {
0000000|                                                        int first, last;
       |
0000000|                                                        codepoint -= 0x10000;
0000000|                                                        first = 0xD800 | ((codepoint & 0xffc00) >> 10);
0000000|                                                        last = 0xDC00 | (codepoint & 0x003ff);
       |
0000000|                                                        dst.formattedWrite("\\u%04X\\u%04X", first, last);
       |                                                }
0000000|                                                startPos = pos;
0000000|                                                pos -= 1;
       |                                        }
       |                                }
       |                                else
       |                                {
    250|                                        if (ch < 0x20)
       |                                        {
0000000|                                                putInterval(pos);
0000000|                                                dst.formattedWrite("\\u%04X", ch);
       |                                        }
       |                                }
    250|                                break;
0000000|                        case '\\': putInterval(pos); dst.put("\\\\"); break;
0000000|                        case '\r': putInterval(pos); dst.put("\\r"); break;
0000000|                        case '\n': putInterval(pos); dst.put("\\n"); break;
0000000|                        case '\t': putInterval(pos); dst.put("\\t"); break;
0000000|                        case '\"': putInterval(pos); dst.put("\\\""); break;
0000000|                        case '/':
       |                                // this avoids the sequence "</" in the output, which is prone
       |                                // to cross site scripting attacks when inserted into web pages
0000000|                                if (pos > 0 && s[pos-1] == '<')
       |                                {
0000000|                                        putInterval(pos);
0000000|                                        dst.put("\\/");
       |                                }
0000000|                                break;
       |                }
       |        }
       |        // last interval
     44|        putInterval(s.length);
       |}
       |
       |/// private
       |private string jsonUnescape(R)(ref R range)
       |{
     43|        auto ret = appender!string();
    360|        while(!range.empty){
    360|                auto ch = range.front;
    360|                switch( ch ){
     86|                        case '"': return ret.data;
0000000|                        case '\\':
0000000|                                range.popFront();
0000000|                                enforceJson(!range.empty, "Unterminated string escape sequence.");
0000000|                                switch(range.front){
0000000|                                        default: enforceJson(false, "Invalid string escape sequence."); break;
0000000|                                        case '"': ret.put('\"'); range.popFront(); break;
0000000|                                        case '\\': ret.put('\\'); range.popFront(); break;
0000000|                                        case '/': ret.put('/'); range.popFront(); break;
0000000|                                        case 'b': ret.put('\b'); range.popFront(); break;
0000000|                                        case 'f': ret.put('\f'); range.popFront(); break;
0000000|                                        case 'n': ret.put('\n'); range.popFront(); break;
0000000|                                        case 'r': ret.put('\r'); range.popFront(); break;
0000000|                                        case 't': ret.put('\t'); range.popFront(); break;
0000000|                                        case 'u':
       |
0000000|                                                dchar decode_unicode_escape() {
0000000|                                                        enforceJson(range.front == 'u');
0000000|                                                        range.popFront();
0000000|                                                        dchar uch = 0;
0000000|                                                        foreach( i; 0 .. 4 ){
0000000|                                                                uch *= 16;
0000000|                                                                enforceJson(!range.empty, "Unicode sequence must be '\\uXXXX'.");
0000000|                                                                auto dc = range.front;
0000000|                                                                range.popFront();
       |
0000000|                                                                if( dc >= '0' && dc <= '9' ) uch += dc - '0';
0000000|                                                                else if( dc >= 'a' && dc <= 'f' ) uch += dc - 'a' + 10;
0000000|                                                                else if( dc >= 'A' && dc <= 'F' ) uch += dc - 'A' + 10;
0000000|                                                                else enforceJson(false, "Unicode sequence must be '\\uXXXX'.");
       |                                                        }
0000000|                                                        return uch;
       |                                                }
       |
0000000|                                                auto uch = decode_unicode_escape();
       |
0000000|                                                if(0xD800 <= uch && uch <= 0xDBFF) {
       |                                                        /* surrogate pair */
0000000|                                                        range.popFront(); // backslash '\'
0000000|                                                        auto uch2 = decode_unicode_escape();
0000000|                                                        enforceJson(0xDC00 <= uch2 && uch2 <= 0xDFFF, "invalid Unicode");
       |                                                        {
       |                                                                /* valid second surrogate */
0000000|                                                                uch =
       |                                                                        ((uch - 0xD800) << 10) +
       |                                                                                (uch2 - 0xDC00) +
       |                                                                                0x10000;
       |                                                        }
       |                                                }
0000000|                                                ret.put(uch);
0000000|                                                break;
       |                                }
0000000|                                break;
    317|                        default:
    317|                                ret.put(ch);
    317|                                range.popFront();
    317|                                break;
       |                }
       |        }
0000000|        return ret.data;
       |}
       |
       |private auto skipNumber(R)(ref R s, out bool is_float, out bool is_long_overflow) @safe
       |        if (isNarrowString!R)
       |{
     10|        auto r = s.representation;
     20|        version (assert) auto rEnd = (() @trusted => r.ptr + r.length - 1)();
     10|        auto res = skipNumber(r, is_float, is_long_overflow);
     20|        version (assert) assert(rEnd == (() @trusted => r.ptr + r.length - 1)()); // check nothing taken off the end
     10|        s = s[$ - r.length .. $];
     10|        return res.assumeUTF();
       |}
       |
       |/// private
       |private auto skipNumber(R)(ref R s, out bool is_float, out bool is_long_overflow)
       |        if (!isNarrowString!R && isForwardRange!R)
       |{
     10|        auto sOrig = s.save;
     10|        size_t idx = 0;
     10|        is_float = false;
     10|        is_long_overflow = false;
     10|        ulong int_part = 0;
     10|        if (s.front == '-') {
0000000|                s.popFront(); ++idx;
       |        }
     10|        if (s.front == '0') {
0000000|                s.popFront(); ++idx;
       |        }
       |        else {
     10|                enforceJson(isDigit(s.front), "Digit expected at beginning of number.");
     10|                int_part = s.front - '0';
     20|                s.popFront(); ++idx;
     58|                while( !s.empty && isDigit(s.front) ) {
     19|                        if (!is_long_overflow) {
     19|                                auto dig = s.front - '0';
     19|                                if ((long.max / 10) > int_part || ((long.max / 10) == int_part && (long.max % 10) >= dig)) {
     19|                                        int_part *= 10;
     19|                                        int_part += dig;
       |                                }
       |                                else {
0000000|                                        is_long_overflow = true;
       |                                }
       |                        }
     38|                        s.popFront(); ++idx;
       |                }
       |        }
       |
     20|        if( !s.empty && s.front == '.' ) {
     18|                s.popFront(); ++idx;
      9|                is_float = true;
     71|                while( !s.empty && isDigit(s.front) ) {
     54|                        s.popFront(); ++idx;
       |                }
       |        }
       |
     28|        if( !s.empty && (s.front == 'e' || s.front == 'E') ) {
0000000|                s.popFront(); ++idx;
0000000|                is_float = true;
0000000|                if( !s.empty && (s.front == '+' || s.front == '-') ) {
0000000|                        s.popFront(); ++idx;
       |                }
0000000|                enforceJson( !s.empty && isDigit(s.front), "Expected exponent." ~ sOrig.takeExactly(idx).to!string);
0000000|                s.popFront(); ++idx;
0000000|                while( !s.empty && isDigit(s.front) ) {
0000000|                        s.popFront(); ++idx;
       |                }
       |        }
       |
     10|        return sOrig.takeExactly(idx);
       |}
       |
       |unittest
       |{
       |        import std.meta : AliasSeq;
       |        // test for string and for a simple range
       |        foreach (foo; AliasSeq!(to!string, map!"a")) {
       |                auto test_1 = foo("9223372036854775806"); // lower then long.max
       |                auto test_2 = foo("9223372036854775807"); // long.max
       |                auto test_3 = foo("9223372036854775808"); // greater then long.max
       |                bool is_float;
       |                bool is_long_overflow;
       |                test_1.skipNumber(is_float, is_long_overflow);
       |                assert(!is_long_overflow);
       |                test_2.skipNumber(is_float, is_long_overflow);
       |                assert(!is_long_overflow);
       |                test_3.skipNumber(is_float, is_long_overflow);
       |                assert(is_long_overflow);
       |        }
       |}
       |
       |/// private
       |private string skipJsonString(R)(ref R s, int* line = null)
       |{
       |        // TODO: count or disallow any newlines inside of the string
     86|        enforceJson(!s.empty && s.front == '"', "Expected '\"' to start string.");
     43|        s.popFront();
     43|        string ret = jsonUnescape(s);
     86|        enforceJson(!s.empty && s.front == '"', "Expected '\"' to terminate string.");
     43|        s.popFront();
     43|        return ret;
       |}
       |
       |/// private
       |private void skipWhitespace(R)(ref R s, int* line = null)
       |{
    171|        while (!s.empty) {
    171|                switch (s.front) {
    300|                        default: return;
     84|                        case ' ', '\t': s.popFront(); break;
0000000|                        case '\n':
0000000|                                s.popFront();
0000000|                                if (!s.empty && s.front == '\r') s.popFront();
0000000|                                if (line) (*line)++;
0000000|                                break;
0000000|                        case '\r':
0000000|                                s.popFront();
0000000|                                if (!s.empty && s.front == '\n') s.popFront();
0000000|                                if (line) (*line)++;
0000000|                                break;
       |                }
       |        }
       |}
       |
    135|private bool isDigit(dchar ch) @safe nothrow pure { return ch >= '0' && ch <= '9'; }
       |
       |private string underscoreStrip(string field_name)
       |@safe nothrow pure {
0000000|        if( field_name.length < 1 || field_name[$-1] != '_' ) return field_name;
0000000|        else return field_name[0 .. $-1];
       |}
       |
       |/// private
       |package template isJsonSerializable(T) { enum isJsonSerializable = is(typeof(T.init.toJson()) == Json) && is(typeof(T.fromJson(Json())) == T); }
       |
       |private void enforceJson(string file = __FILE__, size_t line = __LINE__)(bool cond, lazy string message = "JSON exception")
       |{
     98|        enforceEx!JSONException(cond, message, file, line);
       |}
       |
       |private void enforceJson(string file = __FILE__, size_t line = __LINE__)(bool cond, lazy string message, string err_file, int err_line)
       |{
    207|        enforceEx!JSONException(cond, format("%s(%s): Error: %s", err_file, err_line+1, message), file, line);
       |}
       |
       |private void enforceJson(string file = __FILE__, size_t line = __LINE__)(bool cond, lazy string message, string err_file, int* err_line)
       |{
    216|        enforceJson!(file, line)(cond, message, err_file, err_line ? *err_line : -1);
       |}
       |
       |private auto trustedRange(R)(R range)
       |{
     13|        static struct Rng {
       |                private R range;
     35|                @property bool empty() @trusted { return range.empty; }
     22|                @property auto front() @trusted { return range.front; }
     22|                void popFront() @trusted { range.popFront(); }
       |        }
     13|        return Rng(range);
       |}
       |
       |// test for vibe.utils.DictionaryList
       |@safe unittest {
       |        import vibe.utils.dictionarylist;
       |
       |        static assert(isCustomSerializable!(DictionaryList!int));
       |
       |        DictionaryList!(int, false) b;
       |        b.addField("a", 1);
       |        b.addField("A", 2);
       |        auto app = appender!string();
       |        serializeToJson(app, b);
       |        assert(app.data == `[{"key":"a","value":1},{"key":"A","value":2}]`, app.data);
       |
       |        DictionaryList!(int, true, 2) c;
       |        c.addField("a", 1);
       |        c.addField("b", 2);
       |        c.addField("a", 3);
       |        c.remove("b");
       |        auto appc = appender!string();
       |        serializeToJson(appc, c);
       |        assert(appc.data == `[{"key":"a","value":1},{"key":"a","value":3}]`, appc.data);
       |}
       |
       |// make sure Json is usable for CTFE
       |@safe unittest {
       |        static assert(is(typeof({
       |                struct Test {
       |                        Json object_ = Json.emptyObject;
       |                        Json array   = Json.emptyArray;
       |                }
       |        })), "CTFE for Json type failed.");
       |
       |        static Json test() {
       |                Json j;
       |                j = Json(42);
       |                j = Json([Json(true)]);
       |                j = Json(["foo": Json(null)]);
       |                j = Json("foo");
       |                return j;
       |        }
       |        enum j = test();
       |        static assert(j == Json("foo"));
       |}
       |
       |@safe unittest { // XSS prevention
       |        assert(Json("</script>some/path").toString() == `"<\/script>some/path"`);
       |        assert(serializeToJsonString("</script>some/path") == `"<\/script>some/path"`);
       |}
       |
       |@system unittest { // Recursive structures
       |        static struct Bar { Bar[] foos; int i; }
       |        auto b = deserializeJson!Bar(`{"i":1,"foos":[{"foos":[],"i":2}]}`);
       |        assert(b.i == 1);
       |        assert(b.foos.length == 1);
       |        assert(b.foos[0].i == 2);
       |        assert(b.foos[0].foos.length == 0);
       |}
       |
       |@safe unittest { // Json <-> std.json.JSONValue
       |        auto astr = `{
       |                "null": null,
       |                "string": "Hello",
       |                "integer": 123456,
       |                "uinteger": 18446744073709551614,
       |                "float": 12.34,
       |                "object": { "hello": "world" },
       |                "array": [1, 2, "string"],
       |                "true": true,
       |                "false": false
       |        }`;
       |        auto a = parseJsonString(astr);
       |
       |        // test JSONValue -> Json conversion
       |        assert(Json(cast(JSONValue)a) == a);
       |
       |        // test Json -> JSONValue conversion
       |        auto v = cast(JSONValue)a;
       |        assert(deserializeJson!JSONValue(serializeToJson(v)) == v);
       |
       |        // test JSON strint <-> JSONValue serialization
       |        assert(deserializeJson!JSONValue(astr) == v);
       |        assert(parseJsonString(serializeToJsonString(v)) == a);
       |
       |        // test using std.conv for the conversion
       |        import std.conv : to;
       |        assert(a.to!JSONValue.to!Json == a);
       |        assert(to!Json(to!JSONValue(a)) == a);
       |}
../../../.dub/packages/vibe-d-0.8.3/vibe-d/data/vibe/data/json.d is 39% covered
