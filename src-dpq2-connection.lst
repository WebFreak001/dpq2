       |/**
       | * Represents connection to the PostgreSQL server
       | *
       | * Most functions is correspond to those in the documentation of Postgres:
       | * $(HTTPS https://www.postgresql.org/docs/current/static/libpq.html)
       | */
       |module dpq2.connection;
       |
       |import dpq2.query;
       |import dpq2.args: QueryParams;
       |import dpq2.result;
       |import dpq2.exception;
       |
       |import derelict.pq.pq;
       |import std.conv: to;
       |import std.string: toStringz, fromStringz;
       |import std.exception: enforce, enforceEx;
       |import std.range;
       |import std.stdio: File;
       |import std.socket;
       |import core.exception;
       |import core.time: Duration;
       |
       |/*
       | * Bugs: On Unix connection is not thread safe.
       | *
       | * On Unix, forking a process with open libpq connections can lead
       | * to unpredictable results because the parent and child processes share
       | * the same sockets and operating system resources. For this reason,
       | * such usage is not recommended, though doing an exec from the child
       | * process to load a new executable is safe.
       |
       |
       |
       |int PQisthreadsafe();
       |Returns 1 if the libpq is thread-safe and 0 if it is not.
       |*/
       |
       |/// dumb flag for Connection ctor parametrization
       |struct ConnectionStart {};
       |
       |/// Connection
       |class Connection
       |{
       |    package PGconn* conn;
       |
       |    invariant
       |    {
    469|        assert(conn !is null);
       |    }
       |
       |    /// Makes a new connection to the database server
     12|    this(string connString)
       |    {
      6|        conn = PQconnectdb(toStringz(connString));
       |
      6|        enforceEx!OutOfMemoryError(conn, "Unable to allocate libpq connection data");
       |
      6|        if(status != CONNECTION_OK)
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |    }
       |
       |        /// Starts creation of a connection to the database server in a nonblocking manner
0000000|    this(ConnectionStart, string connString)
       |    {
      1|        conn = PQconnectStart(toStringz(connString));
       |
      1|        enforceEx!OutOfMemoryError(conn, "Unable to allocate libpq connection data");
       |
      1|        if( status == CONNECTION_BAD )
      1|            throw new ConnectionException(this, __FILE__, __LINE__);
       |    }
       |
       |    ~this()
       |    {
      1|        PQfinish( conn );
       |    }
       |
       |    mixin Queries;
       |
       |    /// Returns the blocking status of the database connection
       |    bool isNonBlocking()
       |    {
0000000|        return PQisnonblocking(conn) == 1;
       |    }
       |
       |    /// Sets the nonblocking status of the connection
       |    private void setNonBlocking(bool state)
       |    {
0000000|        if( PQsetnonblocking(conn, state ? 1 : 0 ) == -1 )
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |    }
       |
       |    /// Begin reset the communication channel to the server, in a nonblocking manner
       |    ///
       |    /// Useful only for non-blocking operations.
       |    void resetStart()
       |    {
0000000|        if(PQresetStart(conn) == 0)
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |    }
       |
       |    /// Useful only for non-blocking operations.
       |    PostgresPollingStatusType poll() nothrow
       |    {
      3|        assert(conn);
       |
      6|        return PQconnectPoll(conn);
       |    }
       |
       |    /// Useful only for non-blocking operations.
       |    PostgresPollingStatusType resetPoll() nothrow
       |    {
0000000|        assert(conn);
       |
0000000|        return PQresetPoll(conn);
       |    }
       |
       |    /// Returns the status of the connection
       |    ConnStatusType status() nothrow
       |    {
     20|        return PQstatus(conn);
       |    }
       |
       |    /// If input is available from the server, consume it
       |    ///
       |    /// Useful only for non-blocking operations.
       |    void consumeInput()
       |    {
      4|        assert(conn);
       |
      4|        const size_t r = PQconsumeInput( conn );
      4|        if( r != 1 ) throw new ConnectionException(this, __FILE__, __LINE__);
       |    }
       |
       |    package bool flush()
       |    {
0000000|        assert(conn);
       |
0000000|        auto r = PQflush(conn);
0000000|        if( r == -1 ) throw new ConnectionException(this, __FILE__, __LINE__);
0000000|        return r == 0;
       |    }
       |
       |    /// Obtains the file descriptor number of the connection socket to the server
       |    int posixSocket()
       |    {
      4|        int r = PQsocket(conn);
       |
      4|        if(r == -1)
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |
      8|        return r;
       |    }
       |
       |    /// Obtains duplicate file descriptor number of the connection socket to the server
       |    socket_t posixSocketDuplicate()
       |    {
       |        version(Windows)
       |        {
       |            static assert(false, "FIXME: implement socket duplication");
       |        }
       |        else // Posix OS
       |        {
       |            import core.sys.posix.unistd: dup;
       |
      8|            return cast(socket_t) dup(cast(socket_t) posixSocket);
       |        }
       |    }
       |
       |    /// Obtains std.socket.Socket of the connection to the server
       |    ///
       |    /// Due to a limitation of Socket actually for the Socket creation
       |    /// duplicate of internal posix socket will be used.
       |    Socket socket()
       |    {
      8|        return new Socket(posixSocketDuplicate, AddressFamily.UNSPEC);
       |    }
       |
       |    /// Returns the error message most recently generated by an operation on the connection
       |    string errorMessage() const nothrow
       |    {
      4|        return PQerrorMessage(conn).to!string;
       |    }
       |
       |    /**
       |     * Sets or examines the current notice processor
       |     *
       |     * Returns the previous notice receiver or processor function pointer, and sets the new value.
       |     * If you supply a null function pointer, no action is taken, but the current pointer is returned.
       |     */
       |    PQnoticeProcessor setNoticeProcessor(PQnoticeProcessor proc, void* arg) nothrow
       |    {
0000000|        assert(conn);
       |
0000000|        return PQsetNoticeProcessor(conn, proc, arg);
       |    }
       |
       |    /// Get next result after sending a non-blocking commands. Can return null.
       |    ///
       |    /// Useful only for non-blocking operations.
       |    immutable(Result) getResult()
       |    {
       |        // is guaranteed by libpq that the result will not be changed until it will not be destroyed
     14|        auto r = cast(immutable) PQgetResult(conn);
       |
     14|        if(r)
       |        {
      7|            auto container = new immutable ResultContainer(r);
     14|            return new immutable Result(container);
       |        }
       |
     14|        return null;
       |    }
       |
       |    /// Get result after PQexec* functions or throw exception if pull is empty
       |    package immutable(ResultContainer) createResultContainer(immutable PGresult* r) const
       |    {
    172|        if(r is null) throw new ConnectionException(this, __FILE__, __LINE__);
       |
    170|        return new immutable ResultContainer(r);
       |    }
       |
       |    /// Select single-row mode for the currently-executing query
       |    bool setSingleRowMode()
       |    {
0000000|        return PQsetSingleRowMode(conn) == 1;
       |    }
       |
       |    /**
       |     Try to cancel query
       |
       |     If the cancellation is effective, the current command will
       |     terminate early and return an error result or exception. If the
       |     cancellation will fails (say, because the server was already done
       |     processing the command) there will be no visible result at all.
       |    */
       |    void cancel()
       |    {
0000000|        auto c = new Cancellation(this);
0000000|        c.doCancel;
       |    }
       |
       |    ///
       |    bool isBusy() nothrow
       |    {
0000000|        assert(conn);
       |
0000000|        return PQisBusy(conn) == 1;
       |    }
       |
       |    ///
       |    string parameterStatus(string paramName)
       |    {
0000000|        assert(conn);
       |
0000000|        auto res = PQparameterStatus(conn, toStringz(paramName));
       |
0000000|        if(res is null)
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |
0000000|        return to!string(fromStringz(res));
       |    }
       |
       |    ///
       |    string escapeLiteral(string msg)
       |    {
      1|        assert(conn);
       |
      1|        auto buf = PQescapeLiteral(conn, msg.toStringz, msg.length);
       |
      1|        if(buf is null)
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |
      1|        string res = buf.fromStringz.to!string;
       |
      1|        PQfreemem(buf);
       |
      2|        return res;
       |    }
       |
       |    ///
       |    string escapeIdentifier(string msg)
       |    {
      1|        assert(conn);
       |
      1|        auto buf = PQescapeIdentifier(conn, msg.toStringz, msg.length);
       |
      1|        if(buf is null)
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |
      1|        string res = buf.fromStringz.to!string;
       |
      1|        PQfreemem(buf);
       |
      2|        return res;
       |    }
       |
       |    ///
       |    string dbName() const nothrow
       |    {
      1|        assert(conn);
       |
      2|        return PQdb(conn).fromStringz.to!string;
       |    }
       |
       |    ///
       |    string host() const nothrow
       |    {
0000000|        assert(conn);
       |
0000000|        return PQhost(conn).fromStringz.to!string;
       |    }
       |
       |    ///
       |    int protocolVersion() const nothrow
       |    {
      1|        assert(conn);
       |
      2|        return PQprotocolVersion(conn);
       |    }
       |
       |    ///
       |    int serverVersion() const nothrow
       |    {
      1|        assert(conn);
       |
      2|        return PQserverVersion(conn);
       |    }
       |
       |    ///
       |    void trace(ref File stream)
       |    {
0000000|        PQtrace(conn, stream.getFP);
       |    }
       |
       |    ///
       |    void untrace()
       |    {
0000000|        PQuntrace(conn);
       |    }
       |
       |    ///
       |    void setClientEncoding(string encoding)
       |    {
      1|        if(PQsetClientEncoding(conn, encoding.toStringz) != 0)
0000000|            throw new ConnectionException(this, __FILE__, __LINE__);
       |    }
       |}
       |
       |/// Check connection options in the provided connection string
       |///
       |/// Throws exception if connection string isn't passes check.
       |void connStringCheck(string connString)
       |{
      2|    char* errmsg = null;
      2|    PQconninfoOption* r = PQconninfoParse(connString.toStringz, &errmsg);
       |
      2|    if(r is null)
       |    {
      1|        enforceEx!OutOfMemoryError(errmsg, "Unable to allocate libpq conninfo data");
       |    }
       |    else
       |    {
      1|        PQconninfoFree(r);
       |    }
       |
      2|    if(errmsg !is null)
       |    {
      1|        string s = errmsg.fromStringz.to!string;
      1|        PQfreemem(cast(void*) errmsg);
       |
      1|        throw new ConnectionException(s, __FILE__, __LINE__);
       |    }
       |}
       |
       |unittest
       |{
      1|    connStringCheck("dbname=postgres user=postgres");
       |
       |    {
      1|        bool raised = false;
       |
       |        try
      1|            connStringCheck("wrong conninfo string");
       |        catch(ConnectionException e)
      1|            raised = true;
       |
      1|        assert(raised);
       |    }
       |}
       |
       |/// Represents query cancellation process
       |class Cancellation
       |{
       |    private PGcancel* cancel;
       |
       |    ///
0000000|    this(Connection c)
       |    {
0000000|        cancel = PQgetCancel(c.conn);
       |
0000000|        if(cancel is null)
0000000|            throw new ConnectionException(c, __FILE__, __LINE__);
       |    }
       |
       |    ///
       |    ~this()
       |    {
0000000|        PQfreeCancel(cancel);
       |    }
       |
       |    /**
       |     Requests that the server abandon processing of the current command
       |
       |     Throws exception if cancel request was not successfully dispatched.
       |
       |     Successful dispatch is no guarantee that the request will have any
       |     effect, however. If the cancellation is effective, the current
       |     command will terminate early and return an error result
       |     (exception). If the cancellation fails (say, because the server
       |     was already done processing the command), then there will be no
       |     visible result at all.
       |    */
       |    void doCancel()
       |    {
0000000|        char[256] errbuf;
0000000|        auto res = PQcancel(cancel, errbuf.ptr, errbuf.length);
       |
0000000|        if(res != 1)
0000000|            throw new CancellationException(to!string(errbuf.ptr.fromStringz), __FILE__, __LINE__);
       |    }
       |}
       |
       |///
       |class CancellationException : Dpq2Exception
       |{
0000000|    this(string msg, string file, size_t line)
       |    {
0000000|        super(msg, file, line);
       |    }
       |}
       |
       |/// Connection exception
       |class ConnectionException : Dpq2Exception
       |{
      2|    this(in Connection c, string file, size_t line)
       |    {
      2|        super(c.errorMessage(), file, line);
       |    }
       |
      1|    this(string msg, string file, size_t line)
       |    {
      1|        super(msg, file, line);
       |    }
       |}
       |
       |version (integration_tests)
       |void _integration_test( string connParam )
       |{
      1|    assert( PQlibVersion() >= 9_0100 );
       |
       |    {
       |        debug import std.experimental.logger;
       |
      1|        auto c = new Connection(connParam);
      1|        auto dbname = c.dbName();
      1|        auto pver = c.protocolVersion();
      1|        auto sver = c.serverVersion();
       |
       |        debug
       |        {
      3|            trace("DB name: ", dbname);
      3|            trace("Protocol version: ", pver);
      3|            trace("Server version: ", sver);
       |        }
       |
      1|        destroy(c);
       |    }
       |
       |    {
      1|        bool exceptionFlag = false;
       |
       |        try
      1|            auto c = new Connection(ConnectionStart(), "!!!some incorrect connection string!!!");
       |        catch(ConnectionException e)
       |        {
      1|            exceptionFlag = true;
      1|            assert(e.msg.length > 40); // error message check
       |        }
       |        finally
      1|            assert(exceptionFlag);
       |    }
       |
       |    {
      1|        auto c = new Connection(connParam);
       |
      1|        assert(c.escapeLiteral("abc'def") == "'abc''def'");
      1|        assert(c.escapeIdentifier("abc'def") == "\"abc'def\"");
       |
      1|        c.setClientEncoding("WIN866");
      1|        assert(c.exec("show client_encoding")[0][0].as!string == "WIN866");
       |    }
       |}
src/dpq2/connection.d is 65% covered
