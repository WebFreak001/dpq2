       |﻿/**
       |*   PostgreSQL time types binary format.
       |*
       |*   Copyright: © 2014 DSoftOut
       |*   Authors: NCrashed <ncrashed@gmail.com>
       |*/
       |module dpq2.conv.time;
       |
       |@safe:
       |
       |import dpq2.result;
       |import dpq2.oids: OidType;
       |import dpq2.value: throwTypeComplaint;
       |
       |import core.time;
       |import std.datetime.date : Date, DateTime, TimeOfDay;
       |import std.datetime.systime: SysTime;
       |import std.datetime.timezone: LocalTime, TimeZone, UTC;
       |import std.bitmanip: bigEndianToNative, nativeToBigEndian;
       |import std.math;
       |import std.conv: to;
       |
       |/++
       |    Returns value timestamp with time zone as SysTime
       |
       |    Note that SysTime has a precision in hnsecs and PG TimeStamp in usecs.
       |    It means that PG value will have 10 times lower precision.
       |    And as both types are using long for internal storage it also means that PG TimeStamp can store greater range of values than SysTime.
       |
       |    Because of these differences, it can happen that database value will not fit to the SysTime range of values.
       |+/
       |SysTime binaryValueAs(T)(in Value v) @trusted
       |if( is( T == SysTime ) )
       |{
      2|    if(!(v.oidType == OidType.TimeStampWithZone))
0000000|        throwTypeComplaint(v.oidType, "timestamp with time zone", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == long.sizeof))
0000000|        throw new ValueConvException(ConvExceptionType.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres timestamp with time zone type", __FILE__, __LINE__);
       |
      2|    auto t = rawTimeStamp2nativeTime!TimeStampUTC(bigEndianToNative!long(v.data.ptr[0..long.sizeof]));
      2|    return SysTime(t.dateTime, t.fracSec, UTC());
       |}
       |
       |pure:
       |
       |/// Returns value data as native Date
       |Date binaryValueAs(T)(in Value v) @trusted
       |if( is( T == Date ) )
       |{
      7|    if(!(v.oidType == OidType.Date))
0000000|        throwTypeComplaint(v.oidType, "Date", __FILE__, __LINE__);
       |
      7|    if(!(v.data.length == uint.sizeof))
0000000|        throw new ValueConvException(ConvExceptionType.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres date type", __FILE__, __LINE__);
       |
      7|    int jd = bigEndianToNative!uint(v.data.ptr[0..uint.sizeof]);
     21|    int year, month, day;
      7|    j2date(jd, year, month, day);
       |
       |    // TODO: support PG Date like TTimeStamp manner and remove this check
      7|    if(year > short.max)
      1|        throw new ValueConvException(ConvExceptionType.DATE_VALUE_OVERFLOW,
       |            "Year "~year.to!string~" is bigger than supported by std.datetime.Date", __FILE__, __LINE__);
       |
      6|    return Date(year, month, day);
       |}
       |
       |/// Returns value time without time zone as native TimeOfDay
       |TimeOfDay binaryValueAs(T)(in Value v) @trusted
       |if( is( T == TimeOfDay ) )
       |{
      2|    if(!(v.oidType == OidType.Time))
0000000|        throwTypeComplaint(v.oidType, "time without time zone", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == TimeADT.sizeof))
0000000|        throw new ValueConvException(ConvExceptionType.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres time without time zone type", __FILE__, __LINE__);
       |
      2|    return time2tm(bigEndianToNative!TimeADT(v.data.ptr[0..TimeADT.sizeof]));
       |}
       |
       |/// Returns value timestamp without time zone as TimeStamp
       |TimeStamp binaryValueAs(T)(in Value v) @trusted
       |if( is( T == TimeStamp ) )
       |{
      7|    if(!(v.oidType == OidType.TimeStamp))
0000000|        throwTypeComplaint(v.oidType, "timestamp without time zone", __FILE__, __LINE__);
       |
      7|    if(!(v.data.length == long.sizeof))
0000000|        throw new ValueConvException(ConvExceptionType.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres timestamp without time zone type", __FILE__, __LINE__);
       |
      7|    return rawTimeStamp2nativeTime!TimeStamp(
       |        bigEndianToNative!long(v.data.ptr[0..long.sizeof])
       |    );
       |}
       |
       |/// Returns value timestamp with time zone as TimeStampUTC
       |TimeStampUTC binaryValueAs(T)(in Value v) @trusted
       |if( is( T == TimeStampUTC ) )
       |{
      2|    if(!(v.oidType == OidType.TimeStampWithZone))
0000000|        throwTypeComplaint(v.oidType, "timestamp with time zone", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == long.sizeof))
0000000|        throw new ValueConvException(ConvExceptionType.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres timestamp with time zone type", __FILE__, __LINE__);
       |
      2|    return rawTimeStamp2nativeTime!TimeStampUTC(
       |        bigEndianToNative!long(v.data.ptr[0..long.sizeof])
       |    );
       |}
       |
       |/// Returns value timestamp without time zone as DateTime (it drops the fracSecs from the database value)
       |DateTime binaryValueAs(T)(in Value v) @trusted
       |if( is( T == DateTime ) )
       |{
      1|    return v.binaryValueAs!TimeStamp.dateTime;
       |}
       |
       |///
       |enum InfinityState : byte
       |{
       |    NONE = 0, ///
       |    INFINITY_MIN = -1, ///
       |    INFINITY_MAX = 1, ///
       |}
       |
       |///
       |struct PgDate
       |{
       |    int year; ///
       |    ubyte month; ///
       |    ubyte day; ///
       |
       |    /// '-infinity', earlier than all other dates
     40|    static PgDate earlier() pure { return PgDate(int.min, 0, 0); }
       |
       |    /// 'infinity', later than all other dates
     37|    static PgDate later() pure { return PgDate(int.max, 0, 0); }
       |
     31|    bool isEarlier() const pure { return year == earlier.year; } /// '-infinity'
     28|    bool isLater() const pure { return year == later.year; } /// 'infinity'
       |}
       |
       |///
       |static toPgDate(Date d) pure
       |{
     12|    return PgDate(d.year, d.month, d.day);
       |}
       |
       |/++
       |    Structure to represent PostgreSQL Timestamp with/without time zone
       |+/
       |struct TTimeStamp(bool isWithTZ)
       |{
       |    /**
       |     * Date and time of TimeStamp
       |     *
       |     * If value is '-infinity' or '+infinity' it will be equal PgDate.min or PgDate.max
       |     */
       |    PgDate date;
       |    TimeOfDay time; ///
       |    Duration fracSec; /// fractional seconds, 1 microsecond resolution
       |
       |    ///
     24|    this(DateTime dt, Duration fractionalSeconds = Duration.zero) pure
       |    {
     12|        this(dt.date.toPgDate, dt.timeOfDay, fractionalSeconds);
       |    }
       |
       |    ///
    122|    this(PgDate d, TimeOfDay t = TimeOfDay(), Duration fractionalSeconds = Duration.zero) pure
       |    {
     61|        date = d;
     61|        time = t;
     61|        fracSec = fractionalSeconds;
       |    }
       |
       |    ///
       |    void throwIfNotFitsToDate() const
       |    {
     11|        if(date.year > short.max)
0000000|            throw new ValueConvException(ConvExceptionType.DATE_VALUE_OVERFLOW,
       |                "Year "~date.year.to!string~" is bigger than supported by std.datetime", __FILE__, __LINE__);
       |    }
       |
       |    ///
       |    DateTime dateTime() const pure
       |    {
     13|        if(infinity != InfinityState.NONE)
      2|            throw new ValueConvException(ConvExceptionType.DATE_VALUE_OVERFLOW,
       |                "TTimeStamp value is "~infinity.to!string, __FILE__, __LINE__);
       |
     11|        throwIfNotFitsToDate();
       |
     22|        return DateTime(Date(date.year, date.month, date.day), time);
       |    }
       |
       |    invariant()
       |    {
    283|        assert(fracSec < 1.seconds, "fracSec can't be more than 1 second but contains "~fracSec.to!string);
    283|        assert(fracSec >= Duration.zero, "fracSec is negative: "~fracSec.to!string);
    283|        assert(fracSec % 1.usecs == 0.hnsecs, "fracSec have 1 microsecond resolution but contains "~fracSec.to!string);
       |    }
       |
     62|    bool isEarlier() const pure { return date.isEarlier; } /// '-infinity'
     56|    bool isLater() const pure { return date.isLater; } /// 'infinity'
       |
       |    /// Returns infinity state
       |    InfinityState infinity() const pure
       |    {
       |        with(InfinityState)
       |        {
     31|            if(isEarlier) return INFINITY_MIN;
     27|            if(isLater) return INFINITY_MAX;
       |
     30|            return NONE;
       |        }
       |    }
       |
       |    unittest
       |    {
      2|        assert(TTimeStamp.min == TTimeStamp.min);
      2|        assert(TTimeStamp.max == TTimeStamp.max);
      2|        assert(TTimeStamp.min != TTimeStamp.max);
       |
      2|        assert(TTimeStamp.earlier != TTimeStamp.later);
      2|        assert(TTimeStamp.min != TTimeStamp.earlier);
      2|        assert(TTimeStamp.max != TTimeStamp.later);
       |
      2|        assert(TTimeStamp.min.infinity == InfinityState.NONE);
      2|        assert(TTimeStamp.max.infinity == InfinityState.NONE);
      2|        assert(TTimeStamp.earlier.infinity == InfinityState.INFINITY_MIN);
      2|        assert(TTimeStamp.later.infinity == InfinityState.INFINITY_MAX);
       |    }
       |
       |    /// Returns the TimeStamp farthest in the past which is representable by TimeStamp.
       |    static immutable(TTimeStamp) min()
       |    {
       |        /*
       |        Postgres low value is 4713 BC but here is used -4712 because
       |        "Date uses the Proleptic Gregorian Calendar, so it assumes the
       |        Gregorian leap year calculations for its entire length. As per
       |        ISO 8601, it treats 1 B.C. as year 0, i.e. 1 B.C. is 0, 2 B.C.
       |        is -1, etc." (Phobos docs). But Postgres isn't uses ISO 8601
       |        for date calculation.
       |        */
     11|        return TTimeStamp(PgDate(-4712, 1, 1), TimeOfDay.min, Duration.zero);
       |    }
       |
       |    /// Returns the TimeStamp farthest in the future which is representable by TimeStamp.
       |    static immutable(TTimeStamp) max()
       |    {
     11|        enum maxFract = 1.seconds - 1.usecs;
       |
     11|        return TTimeStamp(PgDate(294276, 12, 31), TimeOfDay(23, 59, 59), maxFract);
       |    }
       |
       |    /// '-infinity', earlier than all other time stamps
      9|    static immutable(TTimeStamp) earlier() pure { return TTimeStamp(PgDate.earlier); }
       |
       |    /// 'infinity', later than all other time stamps
      9|    static immutable(TTimeStamp) later() pure { return TTimeStamp(PgDate.later); }
       |
       |    ///
       |    string toString() const
       |    {
       |        import std.format;
       |
0000000|        return format("%04d-%02d-%02d %s %s", date.year, date.month, date.day, time, fracSec.toString);
       |    }
       |}
       |
       |alias TimeStamp = TTimeStamp!false; /// Unknown TZ timestamp
       |alias TimeStampUTC = TTimeStamp!true; /// Assumed that this is UTC timestamp
       |
       |unittest
       |{
      1|    auto t = TimeStamp(DateTime(2017, 11, 13, 14, 29, 17), 75_678.usecs);
      1|    assert(t.dateTime.hour == 14);
       |}
       |
       |unittest
       |{
      1|    auto dt = DateTime(2017, 11, 13, 14, 29, 17);
      1|    auto t = TimeStamp(dt, 75_678.usecs);
       |
      1|    assert(t.dateTime == dt); // test the implicit conversion to DateTime
       |}
       |
       |unittest
       |{
      1|    auto t = TimeStampUTC(
       |            DateTime(2017, 11, 13, 14, 29, 17),
       |            75_678.usecs
       |        );
       |
      1|    assert(t.dateTime.hour == 14);
      1|    assert(t.fracSec == 75_678.usecs);
       |}
       |
       |unittest
       |{
       |    import std.exception : assertThrown;
       |
      1|    auto e = TimeStampUTC.earlier;
      1|    auto l = TimeStampUTC.later;
       |
      2|    assertThrown!ValueConvException(e.dateTime.hour == 14);
      2|    assertThrown!ValueConvException(l.dateTime.hour == 14);
       |}
       |
       |/// Oid tests
       |unittest
       |{
      1|    assert(detectOidTypeFromNative!TimeStamp == OidType.TimeStamp);
      1|    assert(detectOidTypeFromNative!TimeStampUTC == OidType.TimeStampWithZone);
      1|    assert(detectOidTypeFromNative!SysTime == OidType.TimeStampWithZone);
      1|    assert(detectOidTypeFromNative!Date == OidType.Date);
      1|    assert(detectOidTypeFromNative!TimeOfDay == OidType.Time);
       |}
       |
       |package enum POSTGRES_EPOCH_DATE = Date(2000, 1, 1);
       |package enum POSTGRES_EPOCH_JDATE = POSTGRES_EPOCH_DATE.julianDay;
       |static assert(POSTGRES_EPOCH_JDATE == 2_451_545); // value from Postgres code
       |
       |private:
       |
       |T rawTimeStamp2nativeTime(T)(long raw)
       |if(is(T == TimeStamp) || is(T == TimeStampUTC))
       |{
       |    import core.stdc.time: time_t;
       |
     12|    if(raw == long.max) return T.later; // infinity
     11|    if(raw == long.min) return T.earlier; // -infinity
       |
      9|    pg_tm tm;
      9|    fsec_t ts;
       |
      9|    if(timestamp2tm(raw, tm, ts) < 0)
0000000|        throw new AnswerException(
       |            ExceptionType.OUT_OF_RANGE, "Timestamp is out of range",
       |            __FILE__, __LINE__
       |        );
       |
      9|    TimeStamp ret = raw_pg_tm2nativeTime(tm, ts);
       |
       |    static if(is(T == TimeStamp))
      5|        return ret;
       |    else
      4|        return TimeStampUTC(ret.dateTime, ret.fracSec);
       |}
       |
       |TimeStamp raw_pg_tm2nativeTime(pg_tm tm, fsec_t ts)
       |{
      9|    return TimeStamp(
       |        PgDate(
       |            tm.tm_year,
       |            cast(ubyte) tm.tm_mon,
       |            cast(ubyte) tm.tm_mday
       |        ),
       |        TimeOfDay(
       |            tm.tm_hour,
       |            tm.tm_min,
       |            tm.tm_sec
       |        ),
       |        ts.dur!"usecs"
       |    );
       |}
       |
       |// Here is used names from the original Postgresql source
       |
       |void j2date(int jd, out int year, out int month, out int day)
       |{
     16|    enum MONTHS_PER_YEAR = 12;
       |
     16|    jd += POSTGRES_EPOCH_JDATE;
       |
     16|    uint julian = jd + 32044;
     16|    uint quad = julian / 146097;
     16|    uint extra = (julian - quad * 146097) * 4 + 3;
     16|    julian += 60 + quad * 3 + extra / 146097;
     16|    quad = julian / 1461;
     16|    julian -= quad * 1461;
     16|    int y = julian * 4 / 1461;
     32|    julian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))
       |        + 123;
     16|    year = (y+ quad * 4) - 4800;
     16|    quad = julian * 2141 / 65536;
     16|    day = julian - 7834 * quad / 256;
     16|    month = (quad + 10) % MONTHS_PER_YEAR + 1;
       |}
       |
       |private alias long Timestamp;
       |private alias long TimestampTz;
       |private alias long TimeADT;
       |private alias long TimeOffset;
       |private alias int  fsec_t;      /* fractional seconds (in microseconds) */
       |
       |void TMODULO(ref long t, ref long q, double u)
       |{
      9|    q = cast(long)(t / u);
     18|    if (q != 0) t -= q * cast(long)u;
       |}
       |
       |TimeOfDay time2tm(TimeADT time)
       |{
      2|    immutable long USECS_PER_HOUR  = 3600000000;
      2|    immutable long USECS_PER_MINUTE = 60000000;
      2|    immutable long USECS_PER_SEC = 1000000;
       |
      2|    int tm_hour = cast(int)(time / USECS_PER_HOUR);
      2|    time -= tm_hour * USECS_PER_HOUR;
      2|    int tm_min = cast(int)(time / USECS_PER_MINUTE);
      2|    time -= tm_min * USECS_PER_MINUTE;
      2|    int tm_sec = cast(int)(time / USECS_PER_SEC);
      2|    time -= tm_sec * USECS_PER_SEC;
       |
      2|    return TimeOfDay(tm_hour, tm_min, tm_sec);
       |}
       |
       |struct pg_tm
       |{
       |    int         tm_sec;
       |    int         tm_min;
       |    int         tm_hour;
       |    int         tm_mday;
       |    int         tm_mon;         /* origin 0, not 1 */
       |    int         tm_year;        /* relative to 1900 */
       |    int         tm_wday;
       |    int         tm_yday;
       |    int         tm_isdst;
       |    long        tm_gmtoff;
       |    string      tm_zone;
       |}
       |
       |alias pg_time_t = long;
       |
       |enum USECS_PER_DAY       = 86_400_000_000UL;
       |enum USECS_PER_HOUR      = 3_600_000_000UL;
       |enum USECS_PER_MINUTE    = 60_000_000UL;
       |enum USECS_PER_SEC       = 1_000_000UL;
       |
       |/**
       |* timestamp2tm() - Convert timestamp data type to POSIX time structure.
       |*
       |* Note that year is _not_ 1900-based, but is an explicit full value.
       |* Also, month is one-based, _not_ zero-based.
       |* Returns:
       |*   0 on success
       |*  -1 on out of range
       |*
       |* If attimezone is null, the global timezone (including possibly brute forced
       |* timezone) will be used.
       |*/
       |int timestamp2tm(Timestamp dt, out pg_tm tm, out fsec_t fsec)
       |{
      9|    Timestamp   date;
      9|    Timestamp   time;
      9|    pg_time_t   utime;
       |
      9|    time = dt;
      9|    TMODULO(time, date, USECS_PER_DAY);
       |
      9|    if (time < 0)
       |    {
      5|        time += USECS_PER_DAY;
      5|        date -= 1;
       |    }
       |
      9|    j2date(cast(int) date, tm.tm_year, tm.tm_mon, tm.tm_mday);
      9|    dt2time(time, tm.tm_hour, tm.tm_min, tm.tm_sec, fsec);
       |
      9|    return 0;
       |}
       |
       |void dt2time(Timestamp jd, out int hour, out int min, out int sec, out fsec_t fsec)
       |{
      9|    TimeOffset  time;
       |
      9|    time = jd;
      9|    hour = cast(int)(time / USECS_PER_HOUR);
      9|    time -= hour * USECS_PER_HOUR;
      9|    min = cast(int)(time / USECS_PER_MINUTE);
      9|    time -= min * USECS_PER_MINUTE;
      9|    sec = cast(int)(time / USECS_PER_SEC);
      9|    fsec = cast(int)(time - sec*USECS_PER_SEC);
       |}
src/dpq2/conv/time.d is 91% covered
