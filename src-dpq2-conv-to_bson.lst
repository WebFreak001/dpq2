       |///
       |module dpq2.conv.to_bson;
       |
       |import dpq2.value;
       |import dpq2.oids: OidType;
       |import dpq2.result: ArrayProperties;
       |import dpq2.conv.to_d_types;
       |import dpq2.conv.numeric: rawValueToNumeric;
       |import vibe.data.bson;
       |import std.uuid;
       |import std.datetime: SysTime, dur, TimeZone, UTC;
       |import std.bitmanip: bigEndianToNative, BitArray;
       |import std.conv: to;
       |
       |///
       |Bson as(T)(in Value v)
       |if(is(T == Bson))
       |{
      9|    if(v.isNull)
       |    {
0000000|        return Bson(null);
       |    }
       |    else
       |    {
     11|        if(v.isSupportedArray && ValueFormat.BINARY)
      2|            return arrayValueToBson(v);
       |        else
      7|            return rawValueToBson(v);
       |    }
       |}
       |
       |private:
       |
       |Bson arrayValueToBson(in Value cell)
       |{
      2|    const ap = ArrayProperties(cell);
       |
       |    // empty array
      2|    if(ap.dimsSize.length == 0) return Bson.emptyArray;
       |
      2|    size_t curr_offset = ap.dataOffset;
       |
       |    Bson recursive(size_t dimNum)
       |    {
      4|        const dimSize = ap.dimsSize[dimNum];
      4|        Bson[] res = new Bson[dimSize];
       |
     51|        foreach(elemNum; 0..dimSize)
       |        {
     13|            if(dimNum < ap.dimsSize.length - 1)
       |            {
      2|                res[elemNum] = recursive(dimNum + 1);
       |            }
       |            else
       |            {
     11|                ubyte[int.sizeof] size_net; // network byte order
     11|                size_net[] = cell.data[ curr_offset .. curr_offset + size_net.sizeof ];
     11|                uint size = bigEndianToNative!uint( size_net );
       |
     11|                curr_offset += size_net.sizeof;
       |
     11|                Bson b;
     11|                if(size == size.max) // NULL magic number
       |                {
      4|                    b = Bson(null);
      4|                    size = 0;
       |                }
       |                else
       |                {
      7|                    auto v = Value(cast(ubyte[]) cell.data[curr_offset .. curr_offset + size], ap.OID, false);
      7|                    b = v.as!Bson;
       |                }
       |
     11|                curr_offset += size;
     11|                res[elemNum] = b;
       |            }
       |        }
       |
      4|        return Bson(res);
       |    }
       |
      2|    return recursive(0);
       |}
       |
       |Bson rawValueToBson(in Value v)
       |{
      7|    if(v.format == ValueFormat.TEXT)
       |    {
0000000|        const text = v.valueAsString;
       |
0000000|        if(v.oidType == OidType.Json)
       |        {
0000000|            return Bson(text.parseJsonString);
       |        }
       |
0000000|        return Bson(text);
       |    }
       |
      7|    Bson res;
       |
       |    with(OidType)
       |    with(Bson.Type)
      7|    switch(v.oidType)
       |    {
0000000|        case OidType.Bool:
0000000|            bool n = v.tunnelForBinaryValueAsCalls!PGboolean;
0000000|            res = Bson(n);
0000000|            break;
       |
0000000|        case Int2:
0000000|            auto n = v.tunnelForBinaryValueAsCalls!PGsmallint.to!int;
0000000|            res = Bson(n);
0000000|            break;
       |
      7|        case Int4:
      7|            int n = v.tunnelForBinaryValueAsCalls!PGinteger;
      7|            res = Bson(n);
      7|            break;
       |
0000000|        case Int8:
0000000|            long n = v.tunnelForBinaryValueAsCalls!PGbigint;
0000000|            res = Bson(n);
0000000|            break;
       |
0000000|        case Float8:
0000000|            double n = v.tunnelForBinaryValueAsCalls!PGdouble_precision;
0000000|            res = Bson(n);
0000000|            break;
       |
0000000|        case Numeric:
0000000|            res = Bson(rawValueToNumeric(v.data));
0000000|            break;
       |
0000000|        case Text:
0000000|        case FixedString:
0000000|        case VariableString:
0000000|            res = Bson(v.valueAsString);
0000000|            break;
       |
0000000|        case ByteArray:
0000000|            auto b = BsonBinData(BsonBinData.Type.userDefined, v.data.idup);
0000000|            res = Bson(b);
0000000|            break;
       |
0000000|        case UUID:
       |            // See: https://github.com/vibe-d/vibe.d/issues/2161
       |            // res = Bson(v.tunnelForBinaryValueAsCalls!PGuuid);
0000000|            res = serializeToBson(v.tunnelForBinaryValueAsCalls!PGuuid);
0000000|            break;
       |
0000000|        case TimeStampWithZone:
0000000|            auto ts = v.tunnelForBinaryValueAsCalls!(dpq2.conv.time.TimeStampUTC);
0000000|            auto time = BsonDate(SysTime(ts.dateTime, UTC()));
0000000|            long usecs = ts.fracSec.total!"usecs";
0000000|            res = Bson(["time": Bson(time), "usecs": Bson(usecs)]);
0000000|            break;
       |
0000000|        case Json:
0000000|        case Jsonb:
0000000|            vibe.data.json.Json json = v.tunnelForBinaryValueAsCalls!PGjson;
0000000|            res = Bson(json);
0000000|            break;
       |
0000000|        default:
0000000|            throw new ValueConvException(
       |                    ConvExceptionType.NOT_IMPLEMENTED,
       |                    "Format of the column ("~to!(immutable(char)[])(v.oidType)~") doesn't supported by Value to Bson converter",
       |                    __FILE__, __LINE__
       |                );
       |    }
       |
      7|    return res;
       |}
       |
       |version (integration_tests)
       |public void _integration_test( string connParam )
       |{
       |    import dpq2.connection: Connection;
       |    import dpq2.args: QueryParams;
       |    import std.uuid;
       |    import std.datetime: SysTime, DateTime, UTC;
       |
0000000|    auto conn = new Connection(connParam);
       |
       |    // text answer tests
       |    {
0000000|        auto a = conn.exec(
       |                "SELECT 123::int8 as int_num_value,"~
       |                    "'text string'::text as text_value,"~
       |                    "'123.456'::json as json_numeric_value,"~
       |                    "'\"json_value_string\"'::json as json_text_value"
       |            );
       |
0000000|        auto r = a[0]; // first row
       |
0000000|        assert(r["int_num_value"].as!Bson == Bson("123"));
0000000|        assert(r["text_value"].as!Bson == Bson("text string"));
0000000|        assert(r["json_numeric_value"].as!Bson == Bson(123.456));
0000000|        assert(r["json_text_value"].as!Bson == Bson("json_value_string"));
       |    }
       |
       |    // binary answer tests
0000000|    QueryParams params;
0000000|    params.resultFormat = ValueFormat.BINARY;
       |
       |    {
       |        void testIt(Bson bsonValue, string pgType, string pgValue)
       |        {
0000000|            params.sqlCommand = "SELECT "~pgValue~"::"~pgType~" as bson_test_value";
0000000|            auto answer = conn.execParams(params);
       |
0000000|            immutable Value v = answer[0][0];
0000000|            Bson bsonRes = v.as!Bson;
       |
0000000|            if(v.isNull || !v.isSupportedArray) // standalone
       |            {
0000000|                if(pgType == "numeric") pgType = "string"; // bypass for numeric values represented as strings
       |
0000000|                assert(bsonRes == bsonValue, "Received unexpected value\nreceived bsonType="~to!string(bsonValue.type)~"\nexpected nativeType="~pgType~
       |                    "\nsent pgValue="~pgValue~"\nexpected bsonValue="~to!string(bsonValue)~"\nresult="~to!string(bsonRes));
       |            }
       |            else // arrays
       |            {
0000000|                assert(bsonRes.type == Bson.Type.array && bsonRes.toString == bsonValue.toString,
       |                    "pgType="~pgType~" pgValue="~pgValue~" bsonValue="~to!string(bsonValue));
       |            }
       |        }
       |
       |        alias C = testIt; // "C" means "case"
       |
0000000|        C(Bson(null), "text", "null");
0000000|        C(Bson(null), "integer", "null");
0000000|        C(Bson(true), "boolean", "true");
0000000|        C(Bson(false), "boolean", "false");
0000000|        C(Bson(-32_761), "smallint", "-32761");
0000000|        C(Bson(-2_147_483_646), "integer", "-2147483646");
0000000|        C(Bson(-9_223_372_036_854_775_806), "bigint", "-9223372036854775806");
0000000|        C(Bson(-1234.56789012345), "double precision", "-1234.56789012345");
0000000|        C(Bson("first line\nsecond line"), "text", "'first line\nsecond line'");
0000000|        C(Bson("12345 "), "char(6)", "'12345'");
0000000|        C(Bson("-487778762.918209326"), "numeric", "-487778762.918209326");
       |
0000000|        C(Bson(BsonBinData(
       |                    BsonBinData.Type.userDefined,
       |                    [0x44, 0x20, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x00, 0x21]
       |                )),
       |                "bytea", r"E'\\x44 20 72 75 6c 65 73 00 21'"); // "D rules\x00!" (ASCII)
       |
       |        //See: https://github.com/vibe-d/vibe.d/issues/2161
       |        // C(Bson(UUID("8b9ab33a-96e9-499b-9c36-aad1fe86d640")),
       |        //         "uuid", "'8b9ab33a-96e9-499b-9c36-aad1fe86d640'");
0000000|        C(serializeToBson(UUID("8b9ab33a-96e9-499b-9c36-aad1fe86d640")),
       |                "uuid", "'8b9ab33a-96e9-499b-9c36-aad1fe86d640'");
       |
0000000|        C(Bson([
       |                Bson([Bson([Bson("1")]),Bson([Bson("22")]),Bson([Bson("333")])]),
       |                Bson([Bson([Bson("4")]),Bson([Bson(null)]),Bson([Bson("6")])])
       |            ]), "text[]", "'{{{1},{22},{333}},{{4},{null},{6}}}'");
       |
0000000|        C(Bson.emptyArray, "text[]", "'{}'");
       |
0000000|        C(Bson(["time": Bson(BsonDate(SysTime(DateTime(1997, 12, 17, 7, 37, 16), UTC()))), "usecs": Bson(cast(long) 12)]), "timestamp with time zone", "'1997-12-17 07:37:16.000012 UTC'");
       |
0000000|        C(Bson(Json(["float_value": Json(123.456), "text_str": Json("text string")])), "json", "'{\"float_value\": 123.456,\"text_str\": \"text string\"}'");
       |
0000000|        C(Bson(Json(["float_value": Json(123.456), "text_str": Json("text string")])), "jsonb", "'{\"float_value\": 123.456,\"text_str\": \"text string\"}'");
       |    }
       |}
src/dpq2/conv/to_bson.d is 28% covered
