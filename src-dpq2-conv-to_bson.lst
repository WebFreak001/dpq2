       |///
       |module dpq2.conv.to_bson;
       |
       |import dpq2.value;
       |import dpq2.oids: OidType;
       |import dpq2.result: ArrayProperties;
       |import dpq2.conv.to_d_types;
       |import dpq2.conv.numeric: rawValueToNumeric;
       |import vibe.data.bson;
       |import std.uuid;
       |import std.datetime: SysTime, dur, TimeZone, UTC;
       |import std.bitmanip: bigEndianToNative;
       |import std.conv: to;
       |
       |///
       |Bson as(T)(in Value v)
       |if(is(T == Bson))
       |{
     52|    if(v.isNull)
       |    {
      2|        return Bson(null);
       |    }
       |    else
       |    {
     58|        if(v.isSupportedArray && ValueFormat.BINARY)
      8|            return arrayValueToBson(v);
       |        else
     42|            return rawValueToBson(v);
       |    }
       |}
       |
       |private:
       |
       |Bson arrayValueToBson(in Value cell)
       |{
      8|    const ap = ArrayProperties(cell);
       |
       |    // empty array
      9|    if(ap.dimsSize.length == 0) return Bson.emptyArray;
       |
      7|    size_t curr_offset = ap.dataOffset;
       |
      7|    Bson recursive(size_t dimNum)
       |    {
     21|        const dimSize = ap.dimsSize[dimNum];
     21|        Bson[] res = new Bson[dimSize];
       |
    198|        foreach(elemNum; 0..dimSize)
       |        {
     45|            if(dimNum < ap.dimsSize.length - 1)
       |            {
     14|                res[elemNum] = recursive(dimNum + 1);
       |            }
       |            else
       |            {
     31|                ubyte[int.sizeof] size_net; // network byte order
     31|                size_net[] = cell.data[ curr_offset .. curr_offset + size_net.sizeof ];
     31|                uint size = bigEndianToNative!uint( size_net );
       |
     31|                curr_offset += size_net.sizeof;
       |
     31|                Bson b;
     31|                if(size == size.max) // NULL magic number
       |                {
      7|                    b = Bson(null);
      7|                    size = 0;
       |                }
       |                else
       |                {
     24|                    auto v = Value(cast(ubyte[]) cell.data[curr_offset .. curr_offset + size], ap.OID, false);
     24|                    b = v.as!Bson;
       |                }
       |
     31|                curr_offset += size;
     31|                res[elemNum] = b;
       |            }
       |        }
       |
     21|        return Bson(res);
       |    }
       |
      7|    return recursive(0);
       |}
       |
       |Bson rawValueToBson(in Value v)
       |{
     42|    if(v.format == ValueFormat.TEXT)
       |    {
      4|        const text = v.valueAsString;
       |
      4|        if(v.oidType == OidType.Json)
       |        {
      2|            return Bson(text.parseJsonString);
       |        }
       |
      2|        return Bson(text);
       |    }
       |
     38|    Bson res;
       |
       |    with(OidType)
       |    with(Bson.Type)
     38|    switch(v.oidType)
       |    {
      2|        case OidType.Bool:
      2|            bool n = v.tunnelForBinaryValueAsCalls!PGboolean;
      2|            res = Bson(n);
      2|            break;
       |
      1|        case Int2:
      1|            auto n = v.tunnelForBinaryValueAsCalls!PGsmallint.to!int;
      1|            res = Bson(n);
      1|            break;
       |
     16|        case Int4:
     16|            int n = v.tunnelForBinaryValueAsCalls!PGinteger;
     16|            res = Bson(n);
     16|            break;
       |
      1|        case Int8:
      1|            long n = v.tunnelForBinaryValueAsCalls!PGbigint;
      1|            res = Bson(n);
      1|            break;
       |
      1|        case Float8:
      1|            double n = v.tunnelForBinaryValueAsCalls!PGdouble_precision;
      1|            res = Bson(n);
      1|            break;
       |
      1|        case Numeric:
      1|            res = Bson(rawValueToNumeric(v.data));
      1|            break;
       |
      9|        case Text:
     10|        case FixedString:
     10|        case VariableString:
     10|            res = Bson(v.valueAsString);
     10|            break;
       |
      1|        case ByteArray:
      1|            auto b = BsonBinData(BsonBinData.Type.userDefined, v.data.idup);
      1|            res = Bson(b);
      1|            break;
       |
      1|        case UUID:
      1|            res = Bson(v.tunnelForBinaryValueAsCalls!PGuuid);
      1|            break;
       |
      1|        case TimeStampWithZone:
      1|            auto ts = v.tunnelForBinaryValueAsCalls!(dpq2.conv.time.TimeStampUTC);
      1|            auto time = BsonDate(SysTime(ts.dateTime, UTC()));
      1|            long usecs = ts.fracSec.total!"usecs";
      1|            res = Bson(["time": Bson(time), "usecs": Bson(usecs)]);
      1|            break;
       |
      2|        case Json:
      3|        case Jsonb:
      3|            vibe.data.json.Json json = v.tunnelForBinaryValueAsCalls!PGjson;
      3|            res = Bson(json);
      3|            break;
       |
0000000|        default:
0000000|            throw new ValueConvException(
       |                    ConvExceptionType.NOT_IMPLEMENTED,
       |                    "Format of the column ("~to!(immutable(char)[])(v.oidType)~") doesn't supported by Value to Bson converter",
       |                    __FILE__, __LINE__
       |                );
       |    }
       |
     38|    return res;
       |}
       |
       |version (integration_tests)
       |public void _integration_test( string connParam )
       |{
       |    import dpq2.connection: Connection;
       |    import dpq2.args: QueryParams;
       |    import std.uuid;
       |    import std.datetime: SysTime, DateTime, UTC;
       |
      1|    auto conn = new Connection(connParam);
       |
       |    // text answer tests
       |    {
      1|        auto a = conn.exec(
       |                "SELECT 123::int8 as int_num_value,"~
       |                    "'text string'::text as text_value,"~
       |                    "'123.456'::json as json_numeric_value,"~
       |                    "'\"json_value_string\"'::json as json_text_value"
       |            );
       |
      1|        auto r = a[0]; // first row
       |
      1|        assert(r["int_num_value"].as!Bson == Bson("123"));
      1|        assert(r["text_value"].as!Bson == Bson("text string"));
      1|        assert(r["json_numeric_value"].as!Bson == Bson(123.456));
      1|        assert(r["json_text_value"].as!Bson == Bson("json_value_string"));
       |    }
       |
       |    // binary answer tests
      1|    QueryParams params;
      1|    params.resultFormat = ValueFormat.BINARY;
       |
       |    {
      1|        void testIt(Bson bsonValue, string pgType, string pgValue)
       |        {
     18|            params.sqlCommand = "SELECT "~pgValue~"::"~pgType~" as bson_test_value";
     18|            auto answer = conn.execParams(params);
       |
     18|            immutable Value v = answer[0][0];
     18|            Bson bsonRes = v.as!Bson;
       |
     34|            if(v.isNull || !v.isSupportedArray) // standalone
       |            {
     17|                if(pgType == "numeric") pgType = "string"; // bypass for numeric values represented as strings
       |
     16|                assert(bsonRes == bsonValue, "Received unexpected value\nreceived bsonType="~to!string(bsonValue.type)~"\nexpected nativeType="~pgType~
       |                    "\nsent pgValue="~pgValue~"\nexpected bsonValue="~to!string(bsonValue)~"\nresult="~to!string(bsonRes));
       |            }
       |            else // arrays
       |            {
      4|                assert(bsonRes.type == Bson.Type.array && bsonRes.toString == bsonValue.toString,
       |                    "pgType="~pgType~" pgValue="~pgValue~" bsonValue="~to!string(bsonValue));
       |            }
       |        }
       |
      1|        alias C = testIt; // "C" means "case"
       |
      1|        C(Bson(null), "text", "null");
      1|        C(Bson(null), "integer", "null");
      1|        C(Bson(true), "boolean", "true");
      1|        C(Bson(false), "boolean", "false");
      1|        C(Bson(-32_761), "smallint", "-32761");
      1|        C(Bson(-2_147_483_646), "integer", "-2147483646");
      1|        C(Bson(-9_223_372_036_854_775_806), "bigint", "-9223372036854775806");
      1|        C(Bson(-1234.56789012345), "double precision", "-1234.56789012345");
      1|        C(Bson("first line\nsecond line"), "text", "'first line\nsecond line'");
      1|        C(Bson("12345 "), "char(6)", "'12345'");
      1|        C(Bson("-487778762.918209326"), "numeric", "-487778762.918209326");
       |
      1|        C(Bson(BsonBinData(
       |                    BsonBinData.Type.userDefined,
       |                    [0x44, 0x20, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x00, 0x21]
       |                )),
       |                "bytea", r"E'\\x44 20 72 75 6c 65 73 00 21'"); // "D rules\x00!" (ASCII)
       |
      1|        C(Bson(UUID("8b9ab33a-96e9-499b-9c36-aad1fe86d640")),
       |                "uuid", "'8b9ab33a-96e9-499b-9c36-aad1fe86d640'");
       |
      1|        C(Bson([
       |                Bson([Bson([Bson("1")]),Bson([Bson("22")]),Bson([Bson("333")])]),
       |                Bson([Bson([Bson("4")]),Bson([Bson(null)]),Bson([Bson("6")])])
       |            ]), "text[]", "'{{{1},{22},{333}},{{4},{null},{6}}}'");
       |
      1|        C(Bson.emptyArray, "text[]", "'{}'");
       |
      1|        C(Bson(["time": Bson(BsonDate(SysTime(DateTime(1997, 12, 17, 7, 37, 16), UTC()))), "usecs": Bson(cast(long) 12)]), "timestamp with time zone", "'1997-12-17 07:37:16.000012 UTC'");
       |
      1|        C(Bson(Json(["float_value": Json(123.456), "text_str": Json("text string")])), "json", "'{\"float_value\": 123.456,\"text_str\": \"text string\"}'");
       |
      1|        C(Bson(Json(["float_value": Json(123.456), "text_str": Json("text string")])), "jsonb", "'{\"float_value\": 123.456,\"text_str\": \"text string\"}'");
       |    }
       |}
src/dpq2/conv/to_bson.d is 98% covered
