       |module dpq2.conv.native_tests;
       |
       |import dpq2;
       |import dpq2.conv.arrays : isArrayType;
       |import dpq2.conv.geometric: Line;
       |import std.bitmanip : BitArray;
       |import std.datetime;
       |import std.typecons: Nullable;
       |import std.uuid: UUID;
       |import vibe.data.bson: Bson, deserializeBson;
       |import vibe.data.json: Json, parseJsonString;
       |
       |version (integration_tests)
       |private bool compareArraysWithCareAboutNullables(A, B)(A _a, B _b)
       |{
       |    static assert(is(A == B));
       |
       |    import std.algorithm.comparison : equal;
       |    import std.traits: isInstanceOf;
       |
0000000|    return equal!(
       |        (a, b)
       |        {
       |            static if(isInstanceOf!(Nullable, A))
       |            {
       |                if(a.isNull != b.isNull)
       |                    return false;
       |
       |                if(a.isNull)
       |                    return true;
       |            }
       |
0000000|            return a == b;
       |        }
       |    )(_a, _b);
       |}
       |
       |version (integration_tests)
       |public void _integration_test( string connParam ) @system
       |{
       |    import std.format: format;
       |
0000000|    auto conn = new Connection(connParam);
       |
       |    // to return times in other than UTC time zone but fixed time zone so make the test reproducible in databases with other TZ
0000000|    conn.exec("SET TIMEZONE TO +02");
       |
0000000|    conn.exec("SET lc_monetary = 'en_US.UTF-8'");
       |
0000000|    QueryParams params;
0000000|    params.resultFormat = ValueFormat.BINARY;
       |
       |    {
       |        void testIt(T)(T nativeValue, string pgType, string pgValue)
       |        {
       |            import std.algorithm : strip;
       |            import std.string : representation;
       |
       |            static string formatValue(T val)
       |            {
       |                import std.algorithm : joiner, map, strip;
       |                import std.conv : text, to;
       |                import std.range : chain, ElementType;
       |
       |                // Nullable format deprecation workaround
       |                static if (is(T == Nullable!R, R))
0000000|                    return val.isNull ? "null" : val.get.to!string;
       |                else static if (isArrayType!T && is(ElementType!T == Nullable!E, E))
0000000|                    return chain("[", val.map!(a => a.isNull ? "null" : a.to!string).joiner(", "), "]").text;
0000000|                else return val.to!string;
       |            }
       |
       |            // test string to native conversion
0000000|            params.sqlCommand = format("SELECT %s::%s as d_type_test_value", pgValue is null ? "NULL" : pgValue, pgType);
0000000|            params.args = null;
0000000|            auto answer = conn.execParams(params);
0000000|            immutable Value v = answer[0][0];
       |
0000000|            auto result = v.as!T;
       |
       |            static if(isArrayType!T)
0000000|                const bool assertResult = compareArraysWithCareAboutNullables(result, nativeValue);
       |            else
0000000|                const bool assertResult = result == nativeValue;
       |
0000000|            assert(assertResult,
       |                format("PG to native conv: received unexpected value\nreceived pgType=%s\nexpected nativeType=%s\nsent pgValue=%s\nexpected nativeValue=%s\nresult=%s",
       |                v.oidType, typeid(T), pgValue, formatValue(nativeValue), formatValue(result))
       |            );
       |
       |            {
       |                // test binary to text conversion
0000000|                params.sqlCommand = "SELECT $1::text";
0000000|                params.args = [toValue(nativeValue)];
       |
0000000|                auto answer2 = conn.execParams(params);
0000000|                auto v2 = answer2[0][0];
       |
0000000|                string textResult = v2.isNull
0000000|                    ? "NULL"
0000000|                    : v2.as!string.strip(' ');
       |
0000000|                pgValue = pgValue.strip('\'');
       |
       |                // Special cases:
       |                static if(is(T == PGbytea))
0000000|                    pgValue = `\x442072756c65730021`; // Server formats its reply slightly different from the passed argument
       |
       |                static if(is(T == Json))
       |                {
       |                    // Reformatting by same way in the hope that the data will be sorted same in both cases
0000000|                    pgValue = pgValue.parseJsonString.toString;
0000000|                    textResult = textResult.parseJsonString.toString;
       |                }
       |
0000000|                assert(textResult == pgValue,
       |                    format("Native to PG conv: received unexpected value\nreceived pgType=%s\nsent nativeType=%s\nsent nativeValue=%s\nexpected pgValue=%s\nresult=%s\nexpectedRepresentation=%s\nreceivedRepresentation=%s",
       |                    v.oidType, typeid(T), formatValue(nativeValue), pgValue, textResult, pgValue.representation, textResult.representation)
       |                );
       |            }
       |        }
       |
       |        alias C = testIt; // "C" means "case"
       |
       |        import dpq2.conv.to_d_types: PGTestMoney;
       |
0000000|        C!PGboolean(true, "boolean", "true");
0000000|        C!PGboolean(false, "boolean", "false");
0000000|        C!(Nullable!PGboolean)(Nullable!PGboolean.init, "boolean", "NULL");
0000000|        C!(Nullable!PGboolean)(Nullable!PGboolean(true), "boolean", "true");
0000000|        C!PGsmallint(-32_761, "smallint", "-32761");
0000000|        C!PGinteger(-2_147_483_646, "integer", "-2147483646");
0000000|        C!PGbigint(-9_223_372_036_854_775_806, "bigint", "-9223372036854775806");
0000000|        C!PGTestMoney(PGTestMoney(-123.45), "money", "'-$123.45'");
0000000|        C!PGreal(-12.3456f, "real", "-12.3456");
0000000|        C!PGdouble_precision(-1234.56789012345, "double precision", "-1234.56789012345");
0000000|        C!PGtext("first line\nsecond line", "text", "'first line\nsecond line'");
0000000|        C!PGtext("12345 ", "char(6)", "'12345'");
0000000|        C!PGtext("12345", "varchar(6)", "'12345'");
0000000|        C!(Nullable!PGtext)(Nullable!PGtext.init, "text", "NULL");
0000000|        C!PGbytea([0x44, 0x20, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x00, 0x21],
       |            "bytea", r"E'\\x44 20 72 75 6c 65 73 00 21'"); // "D rules\x00!" (ASCII)
0000000|        C!PGuuid(UUID("8b9ab33a-96e9-499b-9c36-aad1fe86d640"), "uuid", "'8b9ab33a-96e9-499b-9c36-aad1fe86d640'");
0000000|        C!(Nullable!PGuuid)(Nullable!UUID(UUID("8b9ab33a-96e9-499b-9c36-aad1fe86d640")), "uuid", "'8b9ab33a-96e9-499b-9c36-aad1fe86d640'");
0000000|        C!PGvarbit(BitArray([1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1]), "varbit", "'101011010110101'");
0000000|        C!PGvarbit(BitArray([0, 0, 1, 0, 1]), "varbit", "'00101'");
0000000|        C!PGvarbit(BitArray([1, 0, 1, 0, 0]), "varbit", "'10100'");
       |
       |        // numeric testing
0000000|        C!PGnumeric("NaN", "numeric", "'NaN'");
       |
0000000|        const string[] numericTests = [
       |            "42",
       |            "-42",
       |            "0",
       |            "0.0146328",
       |            "0.0007",
       |            "0.007",
       |            "0.07",
       |            "0.7",
       |            "7",
       |            "70",
       |            "700",
       |            "7000",
       |            "70000",
       |
       |            "7.0",
       |            "70.0",
       |            "700.0",
       |            "7000.0",
       |            "70000.000",
       |
       |            "2354877787627192443",
       |            "2354877787627192443.0",
       |            "2354877787627192443.00000",
       |            "-2354877787627192443.00000"
       |        ];
       |
0000000|        foreach(i, s; numericTests)
0000000|            C!PGnumeric(s, "numeric", s);
       |
       |        // date and time testing
0000000|        C!PGdate(Date(2016, 01, 8), "date", "'2016-01-08'");
       |        {
       |            import std.exception : assertThrown;
       |
0000000|            assertThrown!ValueConvException(
0000000|                    C!PGdate(Date(0001, 01, 8), "date", "'5874897-12-31'")
       |                );
       |        }
0000000|        C!PGtime_without_time_zone(TimeOfDay(12, 34, 56), "time without time zone", "'12:34:56'");
0000000|        C!PGtimestamp(PGtimestamp(DateTime(1997, 12, 17, 7, 37, 16), dur!"usecs"(12)), "timestamp without time zone", "'1997-12-17 07:37:16.000012'");
0000000|        C!PGtimestamptz(PGtimestamptz(DateTime(1997, 12, 17, 5, 37, 16), dur!"usecs"(12)), "timestamp with time zone", "'1997-12-17 07:37:16.000012+02'");
0000000|        C!PGtimestamp(PGtimestamp.earlier, "timestamp", "'-infinity'");
0000000|        C!PGtimestamp(PGtimestamp.later, "timestamp", "'infinity'");
0000000|        C!PGtimestamp(PGtimestamp.min, "timestamp", `'4713-01-01 00:00:00 BC'`);
0000000|        C!PGtimestamp(PGtimestamp.max, "timestamp", `'294276-12-31 23:59:59.999999'`);
       |
       |        // SysTime testing
0000000|        auto testTZ = new immutable SimpleTimeZone(2.dur!"hours"); // custom TZ
0000000|        C!SysTime(SysTime(DateTime(1997, 12, 17, 7, 37, 16), dur!"usecs"(12), testTZ), "timestamptz", "'1997-12-17 07:37:16.000012+02'");
0000000|        C!(Nullable!SysTime)(Nullable!SysTime(SysTime(DateTime(1997, 12, 17, 7, 37, 16), dur!"usecs"(12), testTZ)), "timestamptz", "'1997-12-17 07:37:16.000012+02'");
       |
       |        // json
0000000|        C!PGjson(Json(["float_value": Json(123.456), "text_str": Json("text string")]), "json", `'{"float_value": 123.456,"text_str": "text string"}'`);
0000000|        C!(Nullable!PGjson)(Nullable!Json(Json(["foo": Json("bar")])), "json", `'{"foo":"bar"}'`);
       |
       |        // json as string
0000000|        C!string(`{"float_value": 123.456}`, "json", `'{"float_value": 123.456}'`);
       |
       |        // jsonb
0000000|        C!PGjson(Json(["float_value": Json(123.456), "text_str": Json("text string"), "abc": Json(["key": Json("value")])]), "jsonb",
       |            `'{"float_value": 123.456, "text_str": "text string", "abc": {"key": "value"}}'`);
       |
       |        // Geometric
       |        import dpq2.conv.geometric: GeometricInstancesForIntegrationTest;
       |        mixin GeometricInstancesForIntegrationTest;
       |
0000000|        C!Point(Point(1,2), "point", "'(1,2)'");
0000000|        C!PGline(Line(1,2,3), "line", "'{1,2,3}'");
0000000|        C!LineSegment(LineSegment(Point(1,2), Point(3,4)), "lseg", "'[(1,2),(3,4)]'");
0000000|        C!Box(Box(Point(1,2),Point(3,4)), "box", "'(3,4),(1,2)'"); // PG handles box ordered as upper right first and lower left next
0000000|        C!TestPath(TestPath(true, [Point(1,1), Point(2,2), Point(3,3)]), "path", "'((1,1),(2,2),(3,3))'");
0000000|        C!TestPath(TestPath(false, [Point(1,1), Point(2,2), Point(3,3)]), "path", "'[(1,1),(2,2),(3,3)]'");
0000000|        C!Polygon(([Point(1,1), Point(2,2), Point(3,3)]), "polygon", "'((1,1),(2,2),(3,3))'");
0000000|        C!TestCircle(TestCircle(Point(1,2), 10), "circle", "'<(1,2),10>'");
0000000|        C!(Nullable!Point)(Nullable!Point(Point(1,2)), "point", "'(1,2)'");
       |
       |        //Arrays
0000000|        C!(int[][])([[1,2],[3,4]], "int[]", "'{{1,2},{3,4}}'");
0000000|        C!(int[])([], "int[]", "'{}'"); // empty array test
0000000|        C!((Nullable!string)[])([Nullable!string("foo"), Nullable!string.init], "text[]", "'{foo,NULL}'");
0000000|        C!(string[])(["foo","bar", "baz"], "text[]", "'{foo,bar,baz}'");
0000000|        C!(PGjson[])([Json(["foo": Json(42)])], "json[]", `'{"{\"foo\":42}"}'`);
0000000|        C!(PGuuid[])([UUID("8b9ab33a-96e9-499b-9c36-aad1fe86d640")], "uuid[]", "'{8b9ab33a-96e9-499b-9c36-aad1fe86d640}'");
0000000|        C!(Nullable!(int[]))(Nullable!(int[]).init, "int[]", "NULL");
0000000|        C!(Nullable!(int[]))(Nullable!(int[])([1,2,3]), "int[]", "'{1,2,3}'");
       |    }
       |}
src/dpq2/conv/native_tests.d is 0% covered
