       |///
       |module dpq2.conv.geometric;
       |
       |import dpq2.oids: OidType;
       |import dpq2.value: ConvExceptionType, throwTypeComplaint, Value, ValueConvException, ValueFormat;
       |import std.bitmanip: bigEndianToNative, nativeToBigEndian;
       |import std.traits;
       |import std.typecons : Nullable;
       |import std.range.primitives: ElementType;
       |
       |@safe:
       |
       |private template GetRvalueOfMember(T, string memberName)
       |{
       |    mixin("alias MemberType = typeof(T."~memberName~");");
       |
       |    static if(is(MemberType == function))
       |        alias R = ReturnType!(MemberType);
       |    else
       |        alias R = MemberType;
       |
       |    alias GetRvalueOfMember = R;
       |}
       |
       |template isGeometricType(T) if(!is(T == Nullable!N, N))
       |{
       |    enum isGeometricType =
       |            isValidPointType!T
       |        || isValidLineType!T
       |        || isValidPathType!T
       |        || isValidPolygon!T
       |        || isValidCircleType!T
       |        || isValidLineSegmentType!T
       |        || isValidBoxType!T;
       |}
       |
       |/// Checks that type have "x" and "y" members of returning type "double"
       |template isValidPointType(T)
       |{
       |    static if (is(T == Nullable!R, R)) enum isValidPointType = false;
       |    else static if(__traits(compiles, typeof(T.x)) && __traits(compiles, typeof(T.y)))
       |    {
       |        enum isValidPointType =
       |            is(GetRvalueOfMember!(T, "x") == double) &&
       |            is(GetRvalueOfMember!(T, "y") == double);
       |    }
       |    else
       |        enum isValidPointType = false;
       |}
       |
       |unittest
       |{
       |    {
       |        struct PT {double x; double y;}
      1|        assert(isValidPointType!PT);
       |    }
       |
       |    {
       |        struct InvalidPT {double x;}
      1|        assert(!isValidPointType!InvalidPT);
       |    }
       |}
       |
       |/// Checks that type have "min" and "max" members of suitable returning type of point
       |template isValidBoxType(T)
       |{
       |    static if (is(T == Nullable!R, R)) enum isValidBoxType = false;
       |    else static if(__traits(compiles, typeof(T.min)) && __traits(compiles, typeof(T.max)))
       |    {
       |        enum isValidBoxType =
       |            isValidPointType!(GetRvalueOfMember!(T, "min")) &&
       |            isValidPointType!(GetRvalueOfMember!(T, "max"));
       |    }
       |    else
       |        enum isValidBoxType = false;
       |}
       |
       |template isValidLineType(T)
       |{
       |    enum isValidLineType = is(T == Line);
       |}
       |
       |template isValidPathType(T)
       |{
       |    enum isValidPathType = isInstanceOf!(Path, T);
       |}
       |
       |template isValidCircleType(T)
       |{
       |    enum isValidCircleType = isInstanceOf!(Circle, T);
       |}
       |
       |///
       |template isValidLineSegmentType(T)
       |{
       |    static if (is(T == Nullable!R, R)) enum isValidLineSegmentType = false;
       |    else static if(__traits(compiles, typeof(T.start)) && __traits(compiles, typeof(T.end)))
       |    {
       |        enum isValidLineSegmentType =
       |            isValidPointType!(GetRvalueOfMember!(T, "start")) &&
       |            isValidPointType!(GetRvalueOfMember!(T, "end"));
       |    }
       |    else
       |        enum isValidLineSegmentType = false;
       |}
       |
       |///
       |template isValidPolygon(T)
       |{
       |    static if (is(T == Nullable!R, R))
       |        enum isValidPolygon = false;
       |    else
       |        enum isValidPolygon = isArray!T && isValidPointType!(ElementType!T);
       |}
       |
       |unittest
       |{
       |    struct PT {double x; double y;}
      1|    assert(isValidPolygon!(PT[]));
      1|    assert(!isValidPolygon!(PT));
       |}
       |
       |private auto serializePoint(Vec2Ddouble, T)(Vec2Ddouble point, T target)
       |if(isValidPointType!Vec2Ddouble)
       |{
       |    import std.algorithm : copy;
       |
     33|    auto rem = point.x.nativeToBigEndian[0 .. $].copy(target);
     33|    rem = point.y.nativeToBigEndian[0 .. $].copy(rem);
       |
     33|    return rem;
       |}
       |
       |Value toValue(Vec2Ddouble)(Vec2Ddouble pt)
       |if(isValidPointType!Vec2Ddouble)
       |{
      3|    ubyte[] data = new ubyte[16];
      3|    pt.serializePoint(data);
       |
      3|    return createValue(data, OidType.Point);
       |}
       |
       |private auto serializeBox(Box, T)(Box box, T target)
       |{
      3|    auto rem = box.max.serializePoint(target);
      3|    rem = box.min.serializePoint(rem);
       |
      3|    return rem;
       |}
       |
       |Value toValue(Box)(Box box)
       |if(isValidBoxType!Box)
       |{
      3|    ubyte[] data = new ubyte[32];
      3|    box.serializeBox(data);
       |
      3|    return createValue(data, OidType.Box);
       |}
       |
       |/// Infinite line - {A,B,C} (Ax + By + C = 0)
       |struct Line
       |{
       |    double a; ///
       |    double b; ///
       |    double c; ///
       |}
       |
       |///
       |struct Path(Point)
       |if(isValidPointType!Point)
       |{
       |    bool isClosed; ///
       |    Point[] points; ///
       |}
       |
       |///
       |struct Circle(Point)
       |if(isValidPointType!Point)
       |{
       |    Point center; ///
       |    double radius; ///
       |}
       |
       |Value toValue(T)(T line)
       |if(isValidLineType!T)
       |{
       |    import std.algorithm : copy;
       |
      3|    ubyte[] data = new ubyte[24];
       |
      3|    auto rem = line.a.nativeToBigEndian[0 .. $].copy(data);
      3|    rem = line.b.nativeToBigEndian[0 .. $].copy(rem);
      3|    rem = line.c.nativeToBigEndian[0 .. $].copy(rem);
       |
      3|    return createValue(data, OidType.Line);
       |}
       |
       |Value toValue(LineSegment)(LineSegment lseg)
       |if(isValidLineSegmentType!LineSegment)
       |{
      3|    ubyte[] data = new ubyte[32];
       |
      3|    auto rem = lseg.start.serializePoint(data);
      3|    rem = lseg.end.serializePoint(rem);
       |
      3|    return createValue(data, OidType.LineSegment);
       |}
       |
       |Value toValue(T)(T path)
       |if(isValidPathType!T)
       |{
       |    import std.algorithm : copy;
       |
      4|    if(path.points.length < 1)
0000000|        throw new ValueConvException(ConvExceptionType.SIZE_MISMATCH,
       |            "At least one point is needed for Path", __FILE__, __LINE__);
       |
      4|    ubyte[] data = new ubyte[path.points.length * 16 + 5];
       |
      8|    ubyte isClosed = path.isClosed ? 1 : 0;
      4|    auto rem = [isClosed].copy(data);
      4|    rem = (cast(int) path.points.length).nativeToBigEndian[0 .. $].copy(rem);
       |
     36|    foreach (ref p; path.points)
       |    {
      8|        rem = p.serializePoint(rem);
       |    }
       |
      4|    return createValue(data, OidType.Path);
       |}
       |
       |Value toValue(Polygon)(Polygon poly)
       |if(isValidPolygon!Polygon)
       |{
       |    import std.algorithm : copy;
       |
      3|    if(poly.length < 1)
0000000|        throw new ValueConvException(ConvExceptionType.SIZE_MISMATCH,
       |            "At least one point is needed for Polygon", __FILE__, __LINE__);
       |
      3|    ubyte[] data = new ubyte[poly.length * 16 + 4];
      3|    auto rem = (cast(int)poly.length).nativeToBigEndian[0 .. $].copy(data);
       |
     30|    foreach (ref p; poly)
      7|        rem = p.serializePoint(rem);
       |
      3|    return createValue(data, OidType.Polygon);
       |}
       |
       |Value toValue(T)(T c)
       |if(isValidCircleType!T)
       |{
       |    import std.algorithm : copy;
       |
      3|    ubyte[] data = new ubyte[24];
      3|    auto rem = c.center.serializePoint(data);
      3|    c.radius.nativeToBigEndian[0 .. $].copy(rem);
       |
      3|    return createValue(data, OidType.Circle);
       |}
       |
       |/// Caller must ensure that reference to the data will not be passed to elsewhere
       |private Value createValue(const ubyte[] data, OidType oid) pure @trusted
       |{
     22|    return Value(cast(immutable) data, oid);
       |}
       |
       |private alias AE = ValueConvException;
       |private alias ET = ConvExceptionType;
       |
       |/// Convert to Point
       |Vec2Ddouble binaryValueAs(Vec2Ddouble)(in Value v)
       |if(isValidPointType!Vec2Ddouble)
       |{
      3|    if(!(v.oidType == OidType.Point))
      1|        throwTypeComplaint(v.oidType, "Point", __FILE__, __LINE__);
       |
      2|    auto data = v.data;
       |
      2|    if(!(data.length == 16))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres Point size", __FILE__, __LINE__);
       |
      1|    return pointFromBytes!Vec2Ddouble(data[0..16]);
       |}
       |
       |private Vec2Ddouble pointFromBytes(Vec2Ddouble)(in ubyte[16] data) pure
       |if(isValidPointType!Vec2Ddouble)
       |{
     13|    return Vec2Ddouble(data[0..8].bigEndianToNative!double, data[8..16].bigEndianToNative!double);
       |}
       |
       |T binaryValueAs(T)(in Value v)
       |if (is(T == Line))
       |{
      3|    if(!(v.oidType == OidType.Line))
      1|        throwTypeComplaint(v.oidType, "Line", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == 24))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres Line size", __FILE__, __LINE__);
       |
      1|    return Line((v.data[0..8].bigEndianToNative!double), v.data[8..16].bigEndianToNative!double, v.data[16..24].bigEndianToNative!double);
       |}
       |
       |LineSegment binaryValueAs(LineSegment)(in Value v)
       |if(isValidLineSegmentType!LineSegment)
       |{
      3|    if(!(v.oidType == OidType.LineSegment))
      1|        throwTypeComplaint(v.oidType, "LineSegment", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == 32))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres LineSegment size", __FILE__, __LINE__);
       |
       |    alias Point = ReturnType!(LineSegment.start);
       |
      1|    auto start = v.data[0..16].pointFromBytes!Point;
      1|    auto end = v.data[16..32].pointFromBytes!Point;
       |
      1|    return LineSegment(start, end);
       |}
       |
       |Box binaryValueAs(Box)(in Value v)
       |if(isValidBoxType!Box)
       |{
      3|    if(!(v.oidType == OidType.Box))
      1|        throwTypeComplaint(v.oidType, "Box", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == 32))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres Box size", __FILE__, __LINE__);
       |
       |    alias Point = typeof(Box.min);
       |
      1|    Box res;
      1|    res.max = v.data[0..16].pointFromBytes!Point;
      1|    res.min = v.data[16..32].pointFromBytes!Point;
       |
      1|    return res;
       |}
       |
       |T binaryValueAs(T)(in Value v)
       |if(isInstanceOf!(Path, T))
       |{
       |    import std.array : uninitializedArray;
       |
      5|    if(!(v.oidType == OidType.Path))
      1|        throwTypeComplaint(v.oidType, "Path", __FILE__, __LINE__);
       |
      4|    if(!((v.data.length - 5) % 16 == 0))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres Path size", __FILE__, __LINE__);
       |
      3|    T res;
      3|    res.isClosed = v.data[0..1].bigEndianToNative!byte == 1;
      3|    int len = v.data[1..5].bigEndianToNative!int;
       |
      3|    if (len != (v.data.length - 5)/16)
      1|        throw new AE(ET.SIZE_MISMATCH, "Path points number mismatch", __FILE__, __LINE__);
       |
       |    alias Point = typeof(T.points[0]);
       |
      2|    res.points = uninitializedArray!(Point[])(len);
     12|    for (int i=0; i<len; i++)
       |    {
      4|        const ubyte[] b = v.data[ i*16+5 .. i*16+5+16 ];
      4|        res.points[i] = b[0..16].pointFromBytes!Point;
       |    }
       |
      2|    return res;
       |}
       |
       |Polygon binaryValueAs(Polygon)(in Value v)
       |if(isValidPolygon!Polygon)
       |{
       |    import std.array : uninitializedArray;
       |
      4|    if(!(v.oidType == OidType.Polygon))
      1|        throwTypeComplaint(v.oidType, "Polygon", __FILE__, __LINE__);
       |
      3|    if(!((v.data.length - 4) % 16 == 0))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres Polygon size", __FILE__, __LINE__);
       |
      2|    Polygon res;
      2|    int len = v.data[0..4].bigEndianToNative!int;
       |
      2|    if (len != (v.data.length - 4)/16)
      1|        throw new AE(ET.SIZE_MISMATCH, "Path points number mismatch", __FILE__, __LINE__);
       |
       |    alias Point = ElementType!Polygon;
       |
      1|    res = uninitializedArray!(Point[])(len);
      8|    for (int i=0; i<len; i++)
       |    {
      3|        const ubyte[] b = v.data[(i*16+4)..(i*16+16+4)];
      3|        res[i] = b[0..16].pointFromBytes!Point;
       |    }
       |
      1|    return res;
       |}
       |
       |T binaryValueAs(T)(in Value v)
       |if(isInstanceOf!(Circle, T))
       |{
      3|    if(!(v.oidType == OidType.Circle))
      1|        throwTypeComplaint(v.oidType, "Circle", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == 24))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres Circle size", __FILE__, __LINE__);
       |
       |    alias Point = typeof(T.center);
       |
      1|    return T(
       |        v.data[0..16].pointFromBytes!Point,
       |        v.data[16..24].bigEndianToNative!double
       |    );
       |}
       |
       |version (integration_tests)
       |package mixin template GeometricInstancesForIntegrationTest()
       |{
       |    @safe:
       |
       |    import gfm.math;
       |    import dpq2.conv.geometric: Circle, Path;
       |
       |    alias Point = vec2d;
       |    alias Box = box2d;
       |    static struct LineSegment
       |    {
       |        seg2d seg;
       |        alias seg this;
       |
      3|        ref Point start() return { return a; }
      3|        ref Point end() return { return b; }
       |
      4|        this(Point a, Point b)
       |        {
      4|            seg.a = a;
      4|            seg.b = b;
       |        }
       |    }
       |    alias TestPath = Path!Point;
       |    alias Polygon = Point[];
       |    alias TestCircle = Circle!Point;
       |}
       |
       |version (integration_tests)
       |unittest
       |{
       |    mixin GeometricInstancesForIntegrationTest;
       |
       |    // binary write/read
       |    {
      1|        auto pt = Point(1,2);
      1|        assert(pt.toValue.binaryValueAs!Point == pt);
       |
      1|        auto ln = Line(1,2,3);
      3|        assert(ln.toValue.binaryValueAs!Line == ln);
       |
      1|        auto lseg = LineSegment(Point(1,2),Point(3,4));
      2|        assert(lseg.toValue.binaryValueAs!LineSegment == lseg);
       |
      1|        auto b = Box(Point(2,2), Point(1,1));
      1|        assert(b.toValue.binaryValueAs!Box == b);
       |
      1|        auto p = TestPath(false, [Point(1,1), Point(2,2)]);
      2|        assert(p.toValue.binaryValueAs!TestPath == p);
       |
      1|        p = TestPath(true, [Point(1,1), Point(2,2)]);
      2|        assert(p.toValue.binaryValueAs!TestPath == p);
       |
      1|        Polygon poly = [Point(1,1), Point(2,2), Point(3,3)];
      1|        assert(poly.toValue.binaryValueAs!Polygon == poly);
       |
      1|        auto c = TestCircle(Point(1,2), 3);
      2|        assert(c.toValue.binaryValueAs!TestCircle == c);
       |    }
       |
       |    // Invalid OID tests
       |    {
       |        import std.exception : assertThrown;
       |
      1|        auto v = Point(1,1).toValue;
      1|        v.oidType = OidType.Text;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Point);
       |
      1|        v = Line(1,2,3).toValue;
      1|        v.oidType = OidType.Text;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Line);
       |
      1|        v = LineSegment(Point(1,1), Point(2,2)).toValue;
      1|        v.oidType = OidType.Text;
      2|        assertThrown!ValueConvException(v.binaryValueAs!LineSegment);
       |
      1|        v = Box(Point(1,1), Point(2,2)).toValue;
      1|        v.oidType = OidType.Text;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Box);
       |
      1|        v = TestPath(true, [Point(1,1), Point(2,2)]).toValue;
      1|        v.oidType = OidType.Text;
      2|        assertThrown!ValueConvException(v.binaryValueAs!TestPath);
       |
      1|        v = [Point(1,1), Point(2,2)].toValue;
      1|        v.oidType = OidType.Text;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Polygon);
       |
      1|        v = TestCircle(Point(1,1), 3).toValue;
      1|        v.oidType = OidType.Text;
      2|        assertThrown!ValueConvException(v.binaryValueAs!TestCircle);
       |    }
       |
       |    // Invalid data size
       |    {
       |        import std.exception : assertThrown;
       |
      1|        auto v = Point(1,1).toValue;
      1|        v._data = new ubyte[1];
      2|        assertThrown!ValueConvException(v.binaryValueAs!Point);
       |
      1|        v = Line(1,2,3).toValue;
      1|        v._data.length = 1;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Line);
       |
      1|        v = LineSegment(Point(1,1), Point(2,2)).toValue;
      1|        v._data.length = 1;
      2|        assertThrown!ValueConvException(v.binaryValueAs!LineSegment);
       |
      1|        v = Box(Point(1,1), Point(2,2)).toValue;
      1|        v._data.length = 1;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Box);
       |
      1|        v = TestPath(true, [Point(1,1), Point(2,2)]).toValue;
      1|        v._data.length -= 16;
      2|        assertThrown!ValueConvException(v.binaryValueAs!TestPath);
      1|        v._data.length = 1;
      2|        assertThrown!ValueConvException(v.binaryValueAs!TestPath);
       |
      1|        v = [Point(1,1), Point(2,2)].toValue;
      1|        v._data.length -= 16;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Polygon);
      1|        v._data.length = 1;
      2|        assertThrown!ValueConvException(v.binaryValueAs!Polygon);
       |
      1|        v = TestCircle(Point(1,1), 3).toValue;
      1|        v._data.length = 1;
      2|        assertThrown!ValueConvException(v.binaryValueAs!TestCircle);
       |    }
       |}
src/dpq2/conv/geometric.d is 98% covered
