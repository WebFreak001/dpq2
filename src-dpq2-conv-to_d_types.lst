       |///
       |module dpq2.conv.to_d_types;
       |
       |@safe:
       |
       |import dpq2.value;
       |import dpq2.oids: OidType, isNativeInteger, isNativeFloat;
       |import dpq2.connection: Connection;
       |import dpq2.query: QueryParams;
       |import dpq2.result: msg_NOT_BINARY;
       |import dpq2.conv.from_d_types;
       |import dpq2.conv.numeric: rawValueToNumeric;
       |import dpq2.conv.time: binaryValueAs, TimeStamp, TimeStampUTC;
       |import dpq2.conv.geometric: binaryValueAs, Line;
       |
       |import vibe.data.json: Json, parseJsonString;
       |import vibe.data.bson: Bson;
       |import std.traits;
       |import std.uuid;
       |import std.datetime;
       |import std.traits: isScalarType;
       |import std.typecons : Nullable;
       |import std.bitmanip: bigEndianToNative;
       |import std.conv: to;
       |version (unittest) import std.exception : assertThrown;
       |
       |// Supported PostgreSQL binary types
       |alias PGboolean =       bool; /// boolean
       |alias PGsmallint =      short; /// smallint
       |alias PGinteger =       int; /// integer
       |alias PGbigint =        long; /// bigint
       |alias PGreal =          float; /// real
       |alias PGdouble_precision = double; /// double precision
       |alias PGtext =          string; /// text
       |alias PGnumeric =       string; /// numeric represented as string
       |alias PGbytea =         immutable(ubyte)[]; /// bytea
       |alias PGuuid =          UUID; /// UUID
       |alias PGdate =          Date; /// Date (no time of day)
       |alias PGtime_without_time_zone = TimeOfDay; /// Time of day (no date)
       |alias PGtimestamp = TimeStamp; /// Both date and time without time zone
       |alias PGtimestamptz = TimeStampUTC; /// Both date and time stored in UTC time zone
       |alias PGjson =          Json; /// json or jsonb
       |alias PGline =          Line; /// Line (geometric type)
       |
       |private alias VF = ValueFormat;
       |private alias AE = ValueConvException;
       |private alias ET = ConvExceptionType;
       |
       |/**
       |    Returns cell value as a native string based type from text or binary formatted field.
       |    Throws: AssertError if the db value is NULL and Nullable is not used to retrieve the value
       |*/
       |T as(T)(in Value v) pure @trusted
       |if(is(T : string))
       |{
    110|    if(v.format == VF.BINARY)
       |    {
    106|        if(!(
       |            v.oidType == OidType.Text ||
     27|            v.oidType == OidType.FixedString ||
     26|            v.oidType == OidType.VariableString ||
     25|            v.oidType == OidType.Numeric ||
      2|            v.oidType == OidType.Json ||
      1|            v.oidType == OidType.Jsonb ||
      1|            v.oidType == OidType.Name
       |        ))
      1|            throwTypeComplaint(v.oidType, "Text, FixedString, VariableString, Name, Numeric, Json or Jsonb", __FILE__, __LINE__);
       |    }
       |
       |    static if(is(T == Nullable!R, R))
       |    {
      3|        alias Ret = R;
       |
      3|        if (v.isNull)
      3|            return T.init;
       |    }
       |    else
    106|        alias Ret = T;
       |
    106|    Ret r;
       |
    208|    if(v.format == VF.BINARY && v.oidType == OidType.Numeric)
     23|        r = rawValueToNumeric(v.data); // special case for 'numeric' which represented in dpq2 as string
       |    else
     83|        r = v.valueAsString;
       |
       |    static if(is(T == Nullable!R2, R2))
0000000|        return T(r);
       |    else
    104|        return r;
       |}
       |
       |@system unittest
       |{
       |    import core.exception: AssertError;
       |
      1|    auto v = Value(ValueFormat.BINARY, OidType.Text);
       |
      1|    assert(v.isNull);
      2|    assertThrown!AssertError(v.as!string == "");
      1|    assert(v.as!(Nullable!string).isNull == true);
       |}
       |
       |/**
       |    Returns value as D type value from binary formatted field.
       |    Throws: AssertError if the db value is NULL and Nullable is not used to retrieve the value
       |*/
       |T as(T)(in Value v)
       |if(!is(T : string) && !is(T == Bson))
       |{
     66|    if(!(v.format == VF.BINARY))
      1|        throw new AE(ET.NOT_BINARY,
       |            msg_NOT_BINARY, __FILE__, __LINE__);
       |
       |    static if (is(T == Nullable!R, R))
       |    {
      5|        if (v.isNull)
      1|            return T.init;
       |        else
      4|            return T(binaryValueAs!R(v));
       |    }
       |    else
     60|        return binaryValueAs!T(v);
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4, false, ValueFormat.TEXT);
      2|    assertThrown!AE(v.as!int);
       |}
       |
       |package:
       |
       |/*
       | * Something was broken in DMD64 D Compiler v2.079.0-rc.1 so I made this "tunnel"
       | * TODO: remove it and replace by direct binaryValueAs calls
       | */
       |auto tunnelForBinaryValueAsCalls(T)(in Value v)
       |{
     26|    return binaryValueAs!T(v);
       |}
       |
       |string valueAsString(in Value v) pure
       |{
    104|    return (cast(const(char[])) v.data).to!string;
       |}
       |
       |/// Returns value as bytes from binary formatted field
       |T binaryValueAs(T)(in Value v)
       |if(is(T : const ubyte[]))
       |{
      3|    if(!(v.oidType == OidType.ByteArray))
      1|        throwTypeComplaint(v.oidType, "immutable ubyte[]", __FILE__, __LINE__);
       |
      2|    return v.data;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Bool);
      2|    assertThrown!ValueConvException(v.binaryValueAs!(const ubyte[]));
       |}
       |
       |/// Returns cell value as native integer or decimal values
       |///
       |/// Postgres type "numeric" is oversized and not supported by now
       |T binaryValueAs(T)(in Value v)
       |if( isNumeric!(T) )
       |{
       |    static if(isIntegral!(T))
     38|        if(!isNativeInteger(v.oidType))
      1|            throwTypeComplaint(v.oidType, "integral types", __FILE__, __LINE__);
       |
       |    static if(isFloatingPoint!(T))
      5|        if(!isNativeFloat(v.oidType))
      1|            throwTypeComplaint(v.oidType, "floating point types", __FILE__, __LINE__);
       |
     41|    if(!(v.data.length == T.sizeof))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            to!string(v.oidType)~" length ("~to!string(v.data.length)~") isn't equal to native D type "~
       |                to!string(typeid(T))~" size ("~to!string(T.sizeof)~")",
       |            __FILE__, __LINE__);
       |
     37|    ubyte[T.sizeof] s = v.data[0..T.sizeof];
     37|    return bigEndianToNative!(T)(s);
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Bool);
      2|    assertThrown!ValueConvException(v.binaryValueAs!int);
      2|    assertThrown!ValueConvException(v.binaryValueAs!float);
       |
      1|    v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!int);
       |}
       |
       |/// Returns UUID as native UUID value
       |UUID binaryValueAs(T)(in Value v)
       |if( is( T == UUID ) )
       |{
      4|    if(!(v.oidType == OidType.UUID))
      1|        throwTypeComplaint(v.oidType, "UUID", __FILE__, __LINE__);
       |
      3|    if(!(v.data.length == 16))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres UUID size", __FILE__, __LINE__);
       |
      2|    UUID r;
      2|    r.data = v.data;
      2|    return r;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!UUID);
       |
      1|    v = Value([1], OidType.UUID);
      2|    assertThrown!ValueConvException(v.binaryValueAs!UUID);
       |}
       |
       |/// Returns boolean as native bool value
       |bool binaryValueAs(T : bool)(in Value v)
       |if (!is(T == Nullable!R, R))
       |{
     11|    if(!(v.oidType == OidType.Bool))
      1|        throwTypeComplaint(v.oidType, "bool", __FILE__, __LINE__);
       |
     10|    if(!(v.data.length == 1))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres boolean size", __FILE__, __LINE__);
       |
      9|    return v.data[0] != 0;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!bool);
       |
      1|    v = Value([1,2], OidType.Bool);
      2|    assertThrown!ValueConvException(v.binaryValueAs!bool);
       |}
       |
       |/// Returns Vibe.d's Json
       |Json binaryValueAs(T)(in Value v) @trusted
       |if( is( T == Json ) )
       |{
       |    import dpq2.conv.jsonb: jsonbValueToJson;
       |
     10|    Json res;
       |
     10|    switch(v.oidType)
       |    {
      7|        case OidType.Json:
       |            // represent value as text and parse it into Json
      7|            string t = v.valueAsString;
      7|            res = parseJsonString(t);
      7|            break;
       |
      2|        case OidType.Jsonb:
      2|            res = v.jsonbValueToJson;
      2|            break;
       |
      1|        default:
      1|            throwTypeComplaint(v.oidType, "json or jsonb", __FILE__, __LINE__);
       |    }
       |
      9|    return res;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!Json);
       |}
src/dpq2/conv/to_d_types.d is 98% covered
