       |///
       |module dpq2.conv.to_d_types;
       |
       |@safe:
       |
       |import dpq2.value;
       |import dpq2.oids: OidType, isNativeInteger, isNativeFloat;
       |import dpq2.connection: Connection;
       |import dpq2.query: QueryParams;
       |import dpq2.result: msg_NOT_BINARY;
       |import dpq2.conv.from_d_types;
       |import dpq2.conv.numeric: rawValueToNumeric;
       |import dpq2.conv.time: binaryValueAs, TimeStamp, TimeStampUTC;
       |import dpq2.conv.geometric: binaryValueAs, Line;
       |import dpq2.conv.arrays : binaryValueAs;
       |
       |import vibe.data.json: Json, parseJsonString;
       |import vibe.data.bson: Bson;
       |import std.traits;
       |import std.uuid;
       |import std.datetime;
       |import std.traits: isScalarType;
       |import std.typecons : Nullable;
       |import std.bitmanip: bigEndianToNative, BitArray;
       |import std.conv: to;
       |version (unittest) import std.exception : assertThrown;
       |
       |// Supported PostgreSQL binary types
       |alias PGboolean =       bool; /// boolean
       |alias PGsmallint =      short; /// smallint
       |alias PGinteger =       int; /// integer
       |alias PGbigint =        long; /// bigint
       |alias PGreal =          float; /// real
       |alias PGdouble_precision = double; /// double precision
       |alias PGtext =          string; /// text
       |alias PGnumeric =       string; /// numeric represented as string
       |alias PGbytea =         immutable(ubyte)[]; /// bytea
       |alias PGuuid =          UUID; /// UUID
       |alias PGdate =          Date; /// Date (no time of day)
       |alias PGtime_without_time_zone = TimeOfDay; /// Time of day (no date)
       |alias PGtimestamp = TimeStamp; /// Both date and time without time zone
       |alias PGtimestamptz = TimeStampUTC; /// Both date and time stored in UTC time zone
       |alias PGjson =          Json; /// json or jsonb
       |alias PGline =          Line; /// Line (geometric type)
       |alias PGvarbit =        BitArray; /// BitArray
       |
       |private alias VF = ValueFormat;
       |private alias AE = ValueConvException;
       |private alias ET = ConvExceptionType;
       |
       |/**
       |    Returns cell value as a native string based type from text or binary formatted field.
       |    Throws: AssertError if the db value is NULL and Nullable is not used to retrieve the value
       |*/
       |T as(T)(in Value v) pure @trusted
       |if(is(T : const(char)[]))
       |{
     16|    if(v.format == VF.BINARY)
       |    {
     16|        if(!(
       |            v.oidType == OidType.Text ||
0000000|            v.oidType == OidType.FixedString ||
0000000|            v.oidType == OidType.VariableString ||
0000000|            v.oidType == OidType.Numeric ||
0000000|            v.oidType == OidType.Json ||
0000000|            v.oidType == OidType.Jsonb ||
0000000|            v.oidType == OidType.Name
       |        ))
0000000|            throwTypeComplaint(v.oidType, "Text, FixedString, VariableString, Name, Numeric, Json or Jsonb", __FILE__, __LINE__);
       |    }
       |
       |    static if(is(T == Nullable!R, R))
       |    {
       |        alias Ret = R;
       |
      2|        if (v.isNull)
      2|            return T.init;
       |    }
       |    else
       |        alias Ret = T;
       |
     14|    Ret r;
       |
     28|    if(v.format == VF.BINARY && v.oidType == OidType.Numeric)
0000000|        r = rawValueToNumeric(v.data); // special case for 'numeric' which represented in dpq2 as string
       |    else
     14|        r = v.valueAsString;
       |
       |    static if(is(T == Nullable!R2, R2))
0000000|        return T(r);
       |    else
     12|        return r;
       |}
       |
       |@system unittest
       |{
       |    import core.exception: AssertError;
       |
      1|    auto v = Value(ValueFormat.BINARY, OidType.Text);
       |
      1|    assert(v.isNull);
      2|    assertThrown!AssertError(v.as!string == "");
      1|    assert(v.as!(Nullable!string).isNull == true);
       |}
       |
       |/**
       |    Returns value as D type value from binary formatted field.
       |    Throws: AssertError if the db value is NULL and Nullable is not used to retrieve the value
       |*/
       |T as(T)(in Value v)
       |if(!is(T : const(char)[]) && !is(T == Bson))
       |{
     38|    if(!(v.format == VF.BINARY))
      1|        throw new AE(ET.NOT_BINARY,
       |            msg_NOT_BINARY, __FILE__, __LINE__);
       |
       |    static if (is(T == Nullable!R, R))
       |    {
      4|        if (v.isNull)
      1|            return T.init;
       |        else
      3|            return T(binaryValueAs!R(v));
       |    }
       |    else
     33|        return binaryValueAs!T(v);
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4, false, ValueFormat.TEXT);
      2|    assertThrown!AE(v.as!int);
       |}
       |
       |package:
       |
       |/*
       | * Something was broken in DMD64 D Compiler v2.079.0-rc.1 so I made this "tunnel"
       | * TODO: remove it and replace by direct binaryValueAs calls
       | */
       |auto tunnelForBinaryValueAsCalls(T)(in Value v)
       |{
      7|    return binaryValueAs!T(v);
       |}
       |
       |char[] valueAsString(in Value v) pure
       |{
     17|    return (cast(const(char[])) v.data).to!(char[]);
       |}
       |
       |/// Returns value as bytes from binary formatted field
       |T binaryValueAs(T)(in Value v)
       |if(is(T : const ubyte[]))
       |{
      2|    if(!(v.oidType == OidType.ByteArray))
      1|        throwTypeComplaint(v.oidType, "immutable ubyte[]", __FILE__, __LINE__);
       |
      1|    return v.data;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Bool);
      2|    assertThrown!ValueConvException(v.binaryValueAs!(const ubyte[]));
       |}
       |
       |/// Returns cell value as native integer or decimal values
       |///
       |/// Postgres type "numeric" is oversized and not supported by now
       |T binaryValueAs(T)(in Value v)
       |if( isNumeric!(T) )
       |{
       |    static if(isIntegral!(T))
     24|        if(!isNativeInteger(v.oidType))
      1|            throwTypeComplaint(v.oidType, "integral types", __FILE__, __LINE__);
       |
       |    static if(isFloatingPoint!(T))
      2|        if(!isNativeFloat(v.oidType))
      1|            throwTypeComplaint(v.oidType, "floating point types", __FILE__, __LINE__);
       |
     24|    if(!(v.data.length == T.sizeof))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            to!string(v.oidType)~" length ("~to!string(v.data.length)~") isn't equal to native D type "~
       |                to!string(typeid(T))~" size ("~to!string(T.sizeof)~")",
       |            __FILE__, __LINE__);
       |
     22|    ubyte[T.sizeof] s = v.data[0..T.sizeof];
     22|    return bigEndianToNative!(T)(s);
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Bool);
      2|    assertThrown!ValueConvException(v.binaryValueAs!int);
      2|    assertThrown!ValueConvException(v.binaryValueAs!float);
       |
      1|    v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!int);
       |}
       |
       |/// Returns UUID as native UUID value
       |UUID binaryValueAs(T)(in Value v)
       |if( is( T == UUID ) )
       |{
      2|    if(!(v.oidType == OidType.UUID))
      1|        throwTypeComplaint(v.oidType, "UUID", __FILE__, __LINE__);
       |
      1|    if(!(v.data.length == 16))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres UUID size", __FILE__, __LINE__);
       |
0000000|    UUID r;
0000000|    r.data = v.data;
0000000|    return r;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!UUID);
       |
      1|    v = Value([1], OidType.UUID);
      2|    assertThrown!ValueConvException(v.binaryValueAs!UUID);
       |}
       |
       |/// Returns boolean as native bool value
       |bool binaryValueAs(T : bool)(in Value v)
       |if (!is(T == Nullable!R, R))
       |{
      6|    if(!(v.oidType == OidType.Bool))
      1|        throwTypeComplaint(v.oidType, "bool", __FILE__, __LINE__);
       |
      5|    if(!(v.data.length == 1))
      1|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres boolean size", __FILE__, __LINE__);
       |
      4|    return v.data[0] != 0;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!bool);
       |
      1|    v = Value([1,2], OidType.Bool);
      2|    assertThrown!ValueConvException(v.binaryValueAs!bool);
       |}
       |
       |/// Returns Vibe.d's Json
       |Json binaryValueAs(T)(in Value v) @trusted
       |if( is( T == Json ) )
       |{
       |    import dpq2.conv.jsonb: jsonbValueToJson;
       |
      4|    Json res;
       |
      4|    switch(v.oidType)
       |    {
      3|        case OidType.Json:
       |            // represent value as text and parse it into Json
      3|            string t = v.valueAsString;
      3|            res = parseJsonString(t);
      3|            break;
       |
0000000|        case OidType.Jsonb:
0000000|            res = v.jsonbValueToJson;
0000000|            break;
       |
      1|        default:
      1|            throwTypeComplaint(v.oidType, "json or jsonb", __FILE__, __LINE__);
       |    }
       |
      3|    return res;
       |}
       |
       |@system unittest
       |{
      1|    auto v = Value([1], OidType.Int4);
      2|    assertThrown!ValueConvException(v.binaryValueAs!Json);
       |}
       |
       |import money: currency, roundingMode;
       |
       |/// Returns money type
       |///
       |/// Caution: here is no check of fractional precision while conversion!
       |/// See also: PostgreSQL's "lc_monetary" description and "money" package description
       |T binaryValueAs(T)(in Value v) @trusted
       |if( isInstanceOf!(currency, T) &&  T.amount.sizeof == 8 )
       |{
       |    import std.format: format;
       |
      2|    if(v.data.length != T.amount.sizeof)
      1|        throw new AE(
       |            ET.SIZE_MISMATCH,
       |            format(
       |                "%s length (%d) isn't equal to D money type %s size (%d)",
       |                v.oidType.to!string,
       |                v.data.length,
       |                typeid(T).to!string,
       |                T.amount.sizeof
       |            )
       |        );
       |
      1|    T r;
       |
      1|    r.amount = v.data[0 .. T.amount.sizeof].bigEndianToNative!long;
       |
      1|    return r;
       |}
       |
       |package alias PGTestMoney = currency!("TEST_CURR", 2); //TODO: roundingMode.UNNECESSARY
       |
       |unittest
       |{
      1|    auto v = Value([1], OidType.Money);
      2|    assertThrown!ValueConvException(v.binaryValueAs!PGTestMoney);
       |}
       |
       |T binaryValueAs(T)(in Value v) @trusted
       |if( is(T == BitArray) )
       |{
       |    import core.bitop : bitswap;
       |    import std.bitmanip;
       |    import std.format: format;
       |    import std.range : chunks;
       |
      2|    if(v.data.length < int.sizeof)
      1|        throw new AE(
       |            ET.SIZE_MISMATCH,
       |            format(
       |                "%s length (%d) is less than minimum int type size (%d)",
       |                v.oidType.to!string,
       |                v.data.length,
       |                int.sizeof
       |            )
       |        );
       |
      1|    auto data = v.data;
      1|    size_t len = data.read!int;
      1|    size_t[] newData;
      5|    foreach (ch; data.chunks(size_t.sizeof))
       |    {
      1|        ubyte[size_t.sizeof] tmpData;
      1|        tmpData[0 .. ch.length] = ch[];
       |
       |        // DMD Issue 19693
       |        version(DigitalMars)
      1|            auto re = softBitswap(bigEndianToNative!size_t(tmpData));
       |        else
       |            auto re = bitswap(bigEndianToNative!size_t(tmpData));
      1|        newData ~= re;
       |    }
      1|    return T(newData, len);
       |}
       |
       |unittest
       |{
      1|    auto v = Value([1], OidType.VariableBitString);
      2|    assertThrown!ValueConvException(v.binaryValueAs!BitArray);
       |}
src/dpq2/conv/to_d_types.d is 85% covered
