       |///
       |module dpq2.conv.from_d_types;
       |
       |@safe:
       |
       |public import dpq2.conv.arrays : toValue;
       |public import dpq2.conv.geometric : toValue;
       |import dpq2.conv.time : POSTGRES_EPOCH_DATE, TimeStamp, TimeStampUTC;
       |import dpq2.oids : detectOidTypeFromNative, OidType;
       |import dpq2.value : Value, ValueFormat;
       |
       |import std.bitmanip: nativeToBigEndian;
       |import std.datetime.date: Date, DateTime, TimeOfDay;
       |import std.datetime.systime: SysTime;
       |import std.datetime.timezone: LocalTime, TimeZone, UTC;
       |import std.traits: isImplicitlyConvertible, isNumeric, OriginalType, Unqual;
       |import std.typecons : Nullable;
       |import std.uuid: UUID;
       |import vibe.data.json: Json;
       |
       |/// Converts Nullable!T to Value
       |Value toValue(T)(T v)
       |if (is(T == Nullable!R, R))
       |{
     15|    if (v.isNull)
      6|        return Value(ValueFormat.BINARY, detectOidTypeFromNative!T);
       |    else
      9|        return toValue(v.get);
       |}
       |
       |///
       |Value toValue(T)(T v)
       |if(isNumeric!(T))
       |{
     52|    return Value(v.nativeToBigEndian.dup, detectOidTypeFromNative!T, false, ValueFormat.BINARY);
       |}
       |
       |/**
       |    Converts types implicitly convertible to string to PG Value.
       |    Note that if string is null it is written as an empty string.
       |    If NULL is a desired DB value, Nullable!string can be used instead.
       |*/
       |Value toValue(T)(T v, ValueFormat valueFormat = ValueFormat.BINARY) @trusted
       |if(is(T : string))
       |{
       |    import std.string : representation;
       |
       |    static assert(isImplicitlyConvertible!(T, string));
     56|    auto buf = (cast(string) v).representation;
       |
     58|    if(valueFormat == ValueFormat.TEXT) buf ~= 0; // for prepareArgs only
       |
     56|    return Value(buf, OidType.Text, false, valueFormat);
       |}
       |
       |/// Constructs Value from array of bytes
       |Value toValue(T)(T v)
       |if(is(T : immutable(ubyte)[]))
       |{
      2|    return Value(v, detectOidTypeFromNative!(ubyte[]), false, ValueFormat.BINARY);
       |}
       |
       |///
       |Value toValue(T : bool)(T v) @trusted
       |if (!is(T == Nullable!R, R))
       |{
     18|    immutable ubyte[] buf = [ v ? 1 : 0 ];
       |
      9|    return Value(buf, detectOidTypeFromNative!T, false, ValueFormat.BINARY);
       |}
       |
       |/// Constructs Value from Date
       |Value toValue(T)(T v)
       |if (is(Unqual!T == Date))
       |{
       |    import std.conv: to;
       |    import dpq2.value;
       |    import dpq2.conv.time: POSTGRES_EPOCH_JDATE;
       |
      7|    long mj_day = v.modJulianDay;
       |
       |    // max days isn't checked because Phobos Date days value always fits into Postgres Date
      7|    if (mj_day < -POSTGRES_EPOCH_JDATE)
      1|        throw new ValueConvException(
       |                ConvExceptionType.DATE_VALUE_OVERFLOW,
       |                "Date value doesn't fit into Postgres binary Date",
       |                __FILE__, __LINE__
       |            );
       |
      6|    enum mj_pg_epoch = POSTGRES_EPOCH_DATE.modJulianDay;
      6|    long days = mj_day - mj_pg_epoch;
       |
      6|    return Value(nativeToBigEndian(days.to!int).dup, OidType.Date, false);
       |}
       |
       |/// Constructs Value from TimeOfDay
       |Value toValue(T)(T v)
       |if (is(Unqual!T == TimeOfDay))
       |{
      2|    long us = ((60L * v.hour + v.minute) * 60 + v.second) * 1_000_000;
       |
      2|    return Value(nativeToBigEndian(us).dup, OidType.Time, false);
       |}
       |
       |/// Constructs Value from TimeStamp or from TimeStampUTC
       |Value toValue(T)(T v)
       |if (is(Unqual!T == TimeStamp) || is(Unqual!T == TimeStampUTC))
       |{
      9|    long us; /// microseconds
       |
      9|    if(v.isLater) // infinity
      1|        us = us.max;
      8|    else if(v.isEarlier) // -infinity
      1|        us = us.min;
       |    else
       |    {
      7|        enum mj_pg_epoch = POSTGRES_EPOCH_DATE.modJulianDay;
      7|        long j = modJulianDayForIntYear(v.date.year, v.date.month, v.date.day) - mj_pg_epoch;
      7|        us = (((j * 24 + v.time.hour) * 60 + v.time.minute) * 60 + v.time.second) * 1_000_000 + v.fracSec.total!"usecs";
       |    }
       |
      9|    return Value(
       |            nativeToBigEndian(us).dup,
       |            is(Unqual!T == TimeStamp) ? OidType.TimeStamp : OidType.TimeStampWithZone,
       |            false
       |        );
       |}
       |
       |// Wikipedia's magic
       |private auto modJulianDayForIntYear(const int year, const ubyte month, const short day) pure
       |{
     10|    const a = (14 - month) / 12;
     10|    const y = year + 4800 - a;
     10|    const m = month + a * 12 - 3;
       |
     10|    const jd = day + (m*153+2)/5 + y*365 + y/4 - y/100 + y/400 - 32045;
       |
     10|    return jd - 2_400_001;
       |}
       |unittest
       |{
      1|    assert(modJulianDayForIntYear(1858, 11, 17) == 0);
      1|    assert(modJulianDayForIntYear(2010, 8, 24) == 55_432);
      1|    assert(modJulianDayForIntYear(1999, 7, 6) == 51_365);
       |}
       |
       |/++
       |    Constructs Value from DateTime
       |    It uses Timestamp without TZ as a resulting PG type
       |+/
       |Value toValue(T)(T v)
       |if (is(Unqual!T == DateTime))
       |{
      1|    return TimeStamp(v).toValue;
       |}
       |
       |/++
       |    Constructs Value from SysTime
       |    Note that SysTime has a precision in hnsecs and PG TimeStamp in usecs.
       |    It means that PG value will have 10 times lower precision.
       |    And as both types are using long for internal storage it also means that PG TimeStamp can store greater range of values than SysTime.
       |+/
       |Value toValue(T)(T v)
       |if (is(Unqual!T == SysTime))
       |{
      2|    long us = (v - SysTime(POSTGRES_EPOCH_DATE, UTC())).total!"usecs";
       |
      2|    return Value(nativeToBigEndian(us).dup, OidType.TimeStampWithZone, false);
       |}
       |
       |/// Constructs Value from UUID
       |Value toValue(T)(T v)
       |if (is(Unqual!T == UUID))
       |{
      3|    return Value(v.data.dup, OidType.UUID);
       |}
       |
       |/// Constructs Value from Json
       |Value toValue(T)(T v)
       |if (is(Unqual!T == Json))
       |{
      6|    auto r = toValue(v.toString);
      6|    r.oidType = OidType.Json;
       |
      6|    return r;
       |}
       |
       |version(unittest)
       |import dpq2.conv.to_d_types : as;
       |
       |unittest
       |{
      1|    Value v = toValue(cast(short) 123);
       |
      1|    assert(v.oidType == OidType.Int2);
      1|    assert(v.as!short == 123);
       |}
       |
       |unittest
       |{
      1|    Value v = toValue(-123.456);
       |
      1|    assert(v.oidType == OidType.Float8);
      1|    assert(v.as!double == -123.456);
       |}
       |
       |unittest
       |{
      1|    Value v = toValue("Test string");
       |
      1|    assert(v.oidType == OidType.Text);
      1|    assert(v.as!string == "Test string");
       |}
       |
       |// string Null values
       |@system unittest
       |{
       |    {
       |        import core.exception: AssertError;
       |        import std.exception: assertThrown;
       |
      1|        auto v = Nullable!string.init.toValue;
      1|        assert(v.oidType == OidType.Text);
      1|        assert(v.isNull);
       |
      2|        assertThrown!AssertError(v.as!string);
      1|        assert(v.as!(Nullable!string).isNull);
       |    }
       |
       |    {
      1|        string s;
      1|        auto v = s.toValue;
      1|        assert(v.oidType == OidType.Text);
      1|        assert(!v.isNull);
       |    }
       |}
       |
       |unittest
       |{
      1|    immutable ubyte[] buf = [0, 1, 2, 3, 4, 5];
      1|    Value v = toValue(buf);
       |
      1|    assert(v.oidType == OidType.ByteArray);
      1|    assert(v.as!(const ubyte[]) == buf);
       |}
       |
       |unittest
       |{
      1|    Value t = toValue(true);
      1|    Value f = toValue(false);
       |
      1|    assert(t.as!bool == true);
      1|    assert(f.as!bool == false);
       |}
       |
       |unittest
       |{
      1|    Value v = toValue(Nullable!long(1));
      1|    Value nv = toValue(Nullable!bool.init);
       |
      1|    assert(!v.isNull);
      1|    assert(v.oidType == OidType.Int8);
      1|    assert(v.as!long == 1);
       |
      1|    assert(nv.isNull);
      1|    assert(nv.oidType == OidType.Bool);
       |}
       |
       |unittest
       |{
       |    import std.datetime : DateTime;
       |
      1|    Value v = toValue(Nullable!TimeStamp(TimeStamp(DateTime(2017, 1, 2))));
       |
      1|    assert(!v.isNull);
      1|    assert(v.oidType == OidType.TimeStamp);
       |}
       |
       |unittest
       |{
       |    // Date: '2018-1-15'
      1|    auto d = Date(2018, 1, 15);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
      1|    auto d = immutable Date(2018, 1, 15);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: '2000-1-1'
      1|    auto d = Date(2000, 1, 1);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: '0010-2-20'
      1|    auto d = Date(10, 2, 20);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: max (always fits into Postgres Date)
      1|    auto d = Date.max;
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: min (overflow)
       |    import std.exception: assertThrown;
       |    import dpq2.value: ValueConvException;
       |
      1|    auto d = Date.min;
      2|    assertThrown!ValueConvException(d.toValue);
       |}
       |
       |unittest
       |{
       |    // DateTime
      1|    auto d = const DateTime(2018, 2, 20, 1, 2, 3);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.TimeStamp);
      1|    assert(v.as!DateTime == d);
       |}
       |
       |unittest
       |{
       |    // TimeOfDay: '14:29:17'
      1|    auto tod = TimeOfDay(14, 29, 17);
      1|    auto v = toValue(tod);
       |
      1|    assert(v.oidType == OidType.Time);
      1|    assert(v.as!TimeOfDay == tod);
       |}
       |
       |unittest
       |{
       |    // SysTime: '2017-11-13T14:29:17.075678Z'
      1|    auto t = SysTime.fromISOExtString("2017-11-13T14:29:17.075678Z");
      1|    auto v = toValue(t);
       |
      1|    assert(v.oidType == OidType.TimeStampWithZone);
      1|    assert(v.as!SysTime == t);
       |}
       |
       |unittest
       |{
       |    import core.time : usecs;
       |    import std.datetime.date : DateTime;
       |
       |    // TimeStamp: '2017-11-13 14:29:17.075678'
      1|    auto t = TimeStamp(DateTime(2017, 11, 13, 14, 29, 17), 75_678.usecs);
      1|    auto v = toValue(t);
       |
      1|    assert(v.oidType == OidType.TimeStamp);
      1|    assert(v.as!TimeStamp == t);
       |}
       |
       |unittest
       |{
      1|    auto j = Json(["foo":Json("bar")]);
      1|    auto v = j.toValue;
       |
      1|    assert(v.oidType == OidType.Json);
      1|    assert(v.as!Json == j);
       |
      1|    auto nj = Nullable!Json(j);
      1|    auto nv = nj.toValue;
      1|    assert(nv.oidType == OidType.Json);
      1|    assert(!nv.as!(Nullable!Json).isNull);
      1|    assert(nv.as!(Nullable!Json).get == j);
       |}
src/dpq2/conv/from_d_types.d is 100% covered
