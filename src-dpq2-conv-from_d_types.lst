       |///
       |module dpq2.conv.from_d_types;
       |
       |@safe:
       |
       |public import dpq2.conv.arrays : isArrayType, toValue, isStaticArrayString;
       |public import dpq2.conv.geometric : toValue;
       |import dpq2.conv.time : POSTGRES_EPOCH_DATE, TimeStamp, TimeStampUTC;
       |import dpq2.oids : detectOidTypeFromNative, oidConvTo, OidType;
       |import dpq2.value : Value, ValueFormat;
       |
       |import std.bitmanip: nativeToBigEndian, BitArray, append;
       |import std.datetime.date: Date, DateTime, TimeOfDay;
       |import std.datetime.systime: SysTime;
       |import std.datetime.timezone: LocalTime, TimeZone, UTC;
       |import std.traits: isImplicitlyConvertible, isNumeric, isInstanceOf, OriginalType, Unqual, isSomeString;
       |import std.typecons : Nullable;
       |import std.uuid: UUID;
       |import vibe.data.json: Json;
       |import money: currency;
       |
       |/// Converts Nullable!T to Value
       |Value toValue(T)(T v)
       |if (is(T == Nullable!R, R) && !(isArrayType!(typeof(v.get))))
       |{
     10|    if (v.isNull)
      4|        return Value(ValueFormat.BINARY, detectOidTypeFromNative!T);
       |    else
      6|        return toValue(v.get);
       |}
       |
       |/// ditto
       |Value toValue(T)(T v)
       |if (is(T == Nullable!R, R) && (isArrayType!(typeof(v.get))))
       |{
       |    import dpq2.conv.arrays : arrToValue = toValue; // deprecation import workaround
       |    import std.range : ElementType;
       |
0000000|    if (v.isNull)
0000000|        return Value(ValueFormat.BINARY, detectOidTypeFromNative!(ElementType!(typeof(v.get))).oidConvTo!"array");
       |    else
0000000|        return arrToValue(v.get);
       |}
       |
       |///
       |Value toValue(T)(T v)
       |if(isNumeric!(T))
       |{
     55|    return Value(v.nativeToBigEndian.dup, detectOidTypeFromNative!T, false, ValueFormat.BINARY);
       |}
       |
       |/// Convert money.currency to PG value
       |///
       |/// Caution: here is no check of fractional precision while conversion!
       |/// See also: PostgreSQL's "lc_monetary" description and "money" package description
       |Value toValue(T)(T v)
       |if(isInstanceOf!(currency, T) &&  T.amount.sizeof == 8)
       |{
      1|    return Value(v.amount.nativeToBigEndian.dup, OidType.Money, false, ValueFormat.BINARY);
       |}
       |
       |unittest
       |{
       |    import dpq2.conv.to_d_types: PGTestMoney;
       |
      1|    const pgtm = PGTestMoney(-123.45);
       |
      1|    Value v = pgtm.toValue;
       |
      1|    assert(v.oidType == OidType.Money);
      1|    assert(v.as!PGTestMoney == pgtm);
       |}
       |
       |/// Convert std.bitmanip.BitArray to PG value
       |Value toValue(T)(T v) @trusted
       |if(is(Unqual!T == BitArray))
       |{
       |    import std.array : appender;
       |    import core.bitop : bitswap;
       |
      2|    size_t len = v.length / 8 + (v.length % 8 ? 1 : 0);
      1|    auto data = cast(size_t[])v;
      1|    auto buffer = appender!(const ubyte[])();
      1|    buffer.append!uint(cast(uint)v.length);
      6|    foreach (d; data[0 .. v.dim])
       |    {
       |        // DMD Issue 19693
       |        version(DigitalMars)
      1|            auto ntb = nativeToBigEndian(softBitswap(d));
       |        else
       |            auto ntb = nativeToBigEndian(bitswap(d));
      6|        foreach (b; ntb[0 .. len])
       |        {
      1|            buffer.append!ubyte(b);
       |        }
       |
       |    }
      1|    return Value(buffer.data.dup, detectOidTypeFromNative!T, false, ValueFormat.BINARY);
       |}
       |
       |/// Reverses the order of bits - needed because of dmd Issue 19693
       |/// https://issues.dlang.org/show_bug.cgi?id=19693
       |package N softBitswap(N)(N x) pure
       |    if (is(N == uint) || is(N == ulong))
       |{
       |    import core.bitop : bswap;
       |    // swap 1-bit pairs:
       |    enum mask1 = cast(N) 0x5555_5555_5555_5555L;
    101|    x = ((x >> 1) & mask1) | ((x & mask1) << 1);
       |    // swap 2-bit pairs:
       |    enum mask2 = cast(N) 0x3333_3333_3333_3333L;
    101|    x = ((x >> 2) & mask2) | ((x & mask2) << 2);
       |    // swap 4-bit pairs:
       |    enum mask4 = cast(N) 0x0F0F_0F0F_0F0F_0F0FL;
    101|    x = ((x >> 4) & mask4) | ((x & mask4) << 4);
       |
       |    // reverse the order of all bytes:
    101|    x = bswap(x);
       |
    101|    return x;
       |}
       |
       |@trusted unittest
       |{
       |    import std.bitmanip : BitArray;
       |
      1|    auto varbit = BitArray([1,0,1,1,0]);
       |
      1|    Value v = varbit.toValue;
       |
      1|    assert(v.oidType == OidType.VariableBitString);
      1|    assert(v.as!BitArray == varbit);
       |
       |    // test softBitswap
      1|    assert (softBitswap!uint( 0x8000_0100 ) == 0x0080_0001);
     99|    foreach (i; 0 .. 32)
     32|        assert (softBitswap!uint(1 << i) == 1 << 32 - i - 1);
       |
      1|    assert (softBitswap!ulong( 0b1000000000000000000000010000000000000000100000000000000000000001)
       |            == 0b1000000000000000000000010000000000000000100000000000000000000001);
      1|    assert (softBitswap!ulong( 0b1110000000000000000000010000000000000000100000000000000000000001)
       |        == 0b1000000000000000000000010000000000000000100000000000000000000111);
    195|    foreach (i; 0 .. 64)
     64|        assert (softBitswap!ulong(1UL << i) == 1UL << 64 - i - 1);
       |
       |}
       |
       |/**
       |    Converts types implicitly convertible to string to PG Value.
       |    Note that if string is null it is written as an empty string.
       |    If NULL is a desired DB value, Nullable!string can be used instead.
       |*/
       |Value toValue(T)(T v, ValueFormat valueFormat = ValueFormat.BINARY) @trusted
       |if(isSomeString!T || isStaticArrayString!T)
       |{
       |    static if(is(T == string))
       |    {
       |        import std.string : representation;
       |
       |        static assert(isImplicitlyConvertible!(T, string));
     23|        auto buf = (cast(string) v).representation;
       |
     23|        if(valueFormat == ValueFormat.TEXT) buf ~= 0; // for prepareArgs only
       |
     23|        return Value(buf, OidType.Text, false, valueFormat);
       |    }
       |    else
       |    {
       |        // convert to a string
       |        import std.conv : to;
      1|        return toValue(v.to!string, valueFormat);
       |    }
       |}
       |
       |/// Constructs Value from array of bytes
       |Value toValue(T)(T v)
       |if(is(T : immutable(ubyte)[]))
       |{
      1|    return Value(v, detectOidTypeFromNative!(ubyte[]), false, ValueFormat.BINARY);
       |}
       |
       |/// Constructs Value from boolean
       |Value toValue(T : bool)(T v) @trusted
       |if (!is(T == Nullable!R, R))
       |{
     16|    immutable ubyte[] buf = [ v ? 1 : 0 ];
       |
      8|    return Value(buf, detectOidTypeFromNative!T, false, ValueFormat.BINARY);
       |}
       |
       |/// Constructs Value from Date
       |Value toValue(T)(T v)
       |if (is(Unqual!T == Date))
       |{
       |    import std.conv: to;
       |    import dpq2.value;
       |    import dpq2.conv.time: POSTGRES_EPOCH_JDATE;
       |
      6|    long mj_day = v.modJulianDay;
       |
       |    // max days isn't checked because Phobos Date days value always fits into Postgres Date
      6|    if (mj_day < -POSTGRES_EPOCH_JDATE)
      1|        throw new ValueConvException(
       |                ConvExceptionType.DATE_VALUE_OVERFLOW,
       |                "Date value doesn't fit into Postgres binary Date",
       |                __FILE__, __LINE__
       |            );
       |
       |    enum mj_pg_epoch = POSTGRES_EPOCH_DATE.modJulianDay;
      5|    long days = mj_day - mj_pg_epoch;
       |
      5|    return Value(nativeToBigEndian(days.to!int).dup, OidType.Date, false);
       |}
       |
       |/// Constructs Value from TimeOfDay
       |Value toValue(T)(T v)
       |if (is(Unqual!T == TimeOfDay))
       |{
      1|    long us = ((60L * v.hour + v.minute) * 60 + v.second) * 1_000_000;
       |
      1|    return Value(nativeToBigEndian(us).dup, OidType.Time, false);
       |}
       |
       |/// Constructs Value from TimeStamp or from TimeStampUTC
       |Value toValue(T)(T v)
       |if (is(Unqual!T == TimeStamp) || is(Unqual!T == TimeStampUTC))
       |{
      4|    long us; /// microseconds
       |
      4|    if(v.isLater) // infinity
0000000|        us = us.max;
      4|    else if(v.isEarlier) // -infinity
0000000|        us = us.min;
       |    else
       |    {
       |        enum mj_pg_epoch = POSTGRES_EPOCH_DATE.modJulianDay;
      4|        long j = modJulianDayForIntYear(v.date.year, v.date.month, v.date.day) - mj_pg_epoch;
      4|        us = (((j * 24 + v.time.hour) * 60 + v.time.minute) * 60 + v.time.second) * 1_000_000 + v.fracSec.total!"usecs";
       |    }
       |
      4|    return Value(
       |            nativeToBigEndian(us).dup,
       |            is(Unqual!T == TimeStamp) ? OidType.TimeStamp : OidType.TimeStampWithZone,
       |            false
       |        );
       |}
       |
       |private auto modJulianDayForIntYear(const int year, const ubyte month, const short day) pure
       |{
       |    // Wikipedia magic:
       |
      7|    const a = (14 - month) / 12;
      7|    const y = year + 4800 - a;
      7|    const m = month + a * 12 - 3;
       |
      7|    const jd = day + (m*153+2)/5 + y*365 + y/4 - y/100 + y/400 - 32045;
       |
      7|    return jd - 2_400_001;
       |}
       |unittest
       |{
      1|    assert(modJulianDayForIntYear(1858, 11, 17) == 0);
      1|    assert(modJulianDayForIntYear(2010, 8, 24) == 55_432);
      1|    assert(modJulianDayForIntYear(1999, 7, 6) == 51_365);
       |}
       |
       |/++
       |    Constructs Value from DateTime
       |    It uses Timestamp without TZ as a resulting PG type
       |+/
       |Value toValue(T)(T v)
       |if (is(Unqual!T == DateTime))
       |{
      2|    return TimeStamp(v).toValue;
       |}
       |
       |/++
       |    Constructs Value from SysTime
       |    Note that SysTime has a precision in hnsecs and PG TimeStamp in usecs.
       |    It means that PG value will have 10 times lower precision.
       |    And as both types are using long for internal storage it also means that PG TimeStamp can store greater range of values than SysTime.
       |+/
       |Value toValue(T)(T v)
       |if (is(Unqual!T == SysTime))
       |{
      1|    long us = (v - SysTime(POSTGRES_EPOCH_DATE, UTC())).total!"usecs";
       |
      1|    return Value(nativeToBigEndian(us).dup, OidType.TimeStampWithZone, false);
       |}
       |
       |/// Constructs Value from UUID
       |Value toValue(T)(T v)
       |if (is(Unqual!T == UUID))
       |{
0000000|    return Value(v.data.dup, OidType.UUID);
       |}
       |
       |/// Constructs Value from Json
       |Value toValue(T)(T v)
       |if (is(Unqual!T == Json))
       |{
      2|    auto r = toValue(v.toString);
      2|    r.oidType = OidType.Json;
       |
      2|    return r;
       |}
       |
       |version(unittest)
       |import dpq2.conv.to_d_types : as;
       |
       |unittest
       |{
      1|    Value v = toValue(cast(short) 123);
       |
      1|    assert(v.oidType == OidType.Int2);
      1|    assert(v.as!short == 123);
       |}
       |
       |unittest
       |{
      1|    Value v = toValue(-123.456);
       |
      1|    assert(v.oidType == OidType.Float8);
      1|    assert(v.as!double == -123.456);
       |}
       |
       |unittest
       |{
      1|    Value v = toValue("Test string");
       |
      1|    assert(v.oidType == OidType.Text);
      1|    assert(v.as!string == "Test string");
       |}
       |
       |// string Null values
       |@system unittest
       |{
       |    {
       |        import core.exception: AssertError;
       |        import std.exception: assertThrown;
       |
      1|        auto v = Nullable!string.init.toValue;
      1|        assert(v.oidType == OidType.Text);
      1|        assert(v.isNull);
       |
      2|        assertThrown!AssertError(v.as!string);
      1|        assert(v.as!(Nullable!string).isNull);
       |    }
       |
       |    {
      1|        string s;
      1|        auto v = s.toValue;
      1|        assert(v.oidType == OidType.Text);
      1|        assert(!v.isNull);
       |    }
       |}
       |
       |unittest
       |{
      1|    immutable ubyte[] buf = [0, 1, 2, 3, 4, 5];
      1|    Value v = toValue(buf);
       |
      1|    assert(v.oidType == OidType.ByteArray);
      1|    assert(v.as!(const ubyte[]) == buf);
       |}
       |
       |unittest
       |{
      1|    Value t = toValue(true);
      1|    Value f = toValue(false);
       |
      1|    assert(t.as!bool == true);
      1|    assert(f.as!bool == false);
       |}
       |
       |unittest
       |{
      1|    Value v = toValue(Nullable!long(1));
      1|    Value nv = toValue(Nullable!bool.init);
       |
      1|    assert(!v.isNull);
      1|    assert(v.oidType == OidType.Int8);
      1|    assert(v.as!long == 1);
       |
      1|    assert(nv.isNull);
      1|    assert(nv.oidType == OidType.Bool);
       |}
       |
       |unittest
       |{
       |    import std.datetime : DateTime;
       |
      1|    Value v = toValue(Nullable!TimeStamp(TimeStamp(DateTime(2017, 1, 2))));
       |
      1|    assert(!v.isNull);
      1|    assert(v.oidType == OidType.TimeStamp);
       |}
       |
       |unittest
       |{
       |    // Date: '2018-1-15'
      1|    auto d = Date(2018, 1, 15);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
      1|    auto d = immutable Date(2018, 1, 15);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: '2000-1-1'
      1|    auto d = Date(2000, 1, 1);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: '0010-2-20'
      1|    auto d = Date(10, 2, 20);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: max (always fits into Postgres Date)
      1|    auto d = Date.max;
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.Date);
      1|    assert(v.as!Date == d);
       |}
       |
       |unittest
       |{
       |    // Date: min (overflow)
       |    import std.exception: assertThrown;
       |    import dpq2.value: ValueConvException;
       |
      1|    auto d = Date.min;
      2|    assertThrown!ValueConvException(d.toValue);
       |}
       |
       |unittest
       |{
       |    // DateTime
      1|    auto d = const DateTime(2018, 2, 20, 1, 2, 3);
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.TimeStamp);
      1|    assert(v.as!DateTime == d);
       |}
       |
       |unittest
       |{
       |    // Nullable!DateTime
       |    import std.typecons : nullable;
      1|    auto d = nullable(DateTime(2018, 2, 20, 1, 2, 3));
      1|    auto v = toValue(d);
       |
      1|    assert(v.oidType == OidType.TimeStamp);
      1|    assert(v.as!(Nullable!DateTime) == d);
       |
      1|    d.nullify();
      1|    v = toValue(d);
      1|    assert(v.oidType == OidType.TimeStamp);
      1|    assert(v.as!(Nullable!DateTime).isNull);
       |}
       |
       |unittest
       |{
       |    // TimeOfDay: '14:29:17'
      1|    auto tod = TimeOfDay(14, 29, 17);
      1|    auto v = toValue(tod);
       |
      1|    assert(v.oidType == OidType.Time);
      1|    assert(v.as!TimeOfDay == tod);
       |}
       |
       |unittest
       |{
       |    // SysTime: '2017-11-13T14:29:17.075678Z'
      1|    auto t = SysTime.fromISOExtString("2017-11-13T14:29:17.075678Z");
      1|    auto v = toValue(t);
       |
      1|    assert(v.oidType == OidType.TimeStampWithZone);
      1|    assert(v.as!SysTime == t);
       |}
       |
       |unittest
       |{
       |    import core.time : usecs;
       |    import std.datetime.date : DateTime;
       |
       |    // TimeStamp: '2017-11-13 14:29:17.075678'
      1|    auto t = TimeStamp(DateTime(2017, 11, 13, 14, 29, 17), 75_678.usecs);
      1|    auto v = toValue(t);
       |
      1|    assert(v.oidType == OidType.TimeStamp);
      1|    assert(v.as!TimeStamp == t);
       |}
       |
       |unittest
       |{
      1|    auto j = Json(["foo":Json("bar")]);
      1|    auto v = j.toValue;
       |
      1|    assert(v.oidType == OidType.Json);
      1|    assert(v.as!Json == j);
       |
      1|    auto nj = Nullable!Json(j);
      1|    auto nv = nj.toValue;
      1|    assert(nv.oidType == OidType.Json);
      1|    assert(!nv.as!(Nullable!Json).isNull);
      1|    assert(nv.as!(Nullable!Json).get == j);
       |}
       |
       |unittest
       |{
       |    import dpq2.conv.to_d_types : as;
      1|    char[2] arr;
      1|    auto v = arr.toValue();
      1|    assert(v.oidType == OidType.Text);
      1|    assert(!v.isNull);
       |
      1|    auto varr = v.as!string;
      1|    assert(varr.length == 2);
       |}
src/dpq2/conv/from_d_types.d is 96% covered
